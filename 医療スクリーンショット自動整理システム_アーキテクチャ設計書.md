# åŒ»ç™‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆè‡ªå‹•æ•´ç†ã‚·ã‚¹ãƒ†ãƒ  ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸

**ä½œæˆæ—¥**: 2025-12-28
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0
**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå**: MedScreenArchiver

---

## 1. ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### 1.1 å…¨ä½“æ§‹æˆå›³

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ãƒ¦ãƒ¼ã‚¶ãƒ¼ç’°å¢ƒ                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆâ”‚  â†’    â”‚  ç›£è¦–ãƒ•ã‚©ãƒ«ãƒ€  â”‚                   â”‚
â”‚  â”‚   (macOS)     â”‚        â”‚  Screenshots  â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  MedScreenArchiver        â”‚
                    â”‚  (Python Application)     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                         â”‚                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ File Monitor  â”‚       â”‚  Image Analyzer   â”‚     â”‚ Image Manager   â”‚
â”‚  (watchdog)   â”‚       â”‚  (Claude API)     â”‚     â”‚ (æ‰‹å‹•ä¿å­˜/å‰Šé™¤)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                         â”‚                         â”‚
        â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
        â”‚               â”‚  Privacy Masker   â”‚               â”‚
        â”‚               â”‚  (å€‹äººæƒ…å ±å‰Šé™¤)    â”‚               â”‚
        â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
        â”‚                         â”‚                         â”‚
        â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
        â”‚               â”‚    Classifier     â”‚               â”‚
        â”‚               â”‚   (è‡ªå‹•åˆ†é¡)       â”‚               â”‚
        â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
        â”‚                         â”‚                         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Database Layer       â”‚
                    â”‚  (SQLite + File System)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                         â”‚                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Similar       â”‚       â”‚  Search Engine    â”‚     â”‚  Notification   â”‚
â”‚ Detector      â”‚       â”‚  (Full-text)      â”‚     â”‚  (macOS)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

```
[ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ]
    â†“
[1. æ¤œçŸ¥] (monitor.py)
    â†“
[2. ç”»åƒèª­ã¿è¾¼ã¿] (analyzer.py)
    â†“
[3. Claude APIã§è§£æ] (analyzer.py)
    â†“ (OCR + å†…å®¹ç†è§£ + å‡ºå…¸æŠ½å‡º)
    â†“
[4. å€‹äººæƒ…å ±ãƒã‚¹ã‚­ãƒ³ã‚°] (privacy.py)
    â†“ (æ°åãƒ»ç”Ÿå¹´æœˆæ—¥ãƒ»IDå‰Šé™¤ã€æ€§åˆ¥ãƒ»å¹´é½¢ä¿æŒ)
    â†“
[5. ã‚«ãƒ†ã‚´ãƒªåˆ†é¡] (classifier.py)
    â†“
[6. é¡ä¼¼è³‡æ–™æ¤œå‡º] (similar_detector.py)
    â†“
[7. Markdownç”Ÿæˆ + DBä¿å­˜] (database.py)
    â†“
[8. é€šçŸ¥] (main.py)
    â†“
[9. ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¤æ–­: ç”»åƒä¿å­˜ or å‰Šé™¤] (image_manager.py)
```

---

## 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è©³ç´°è¨­è¨ˆ

### 2.1 main.py - ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

#### è²¬å‹™
- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
- å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–ã¨èª¿æ•´
- CLIã‚³ãƒãƒ³ãƒ‰ã®æä¾›

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
class MedScreenArchiver:
    """ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹"""

    def __init__(self, config_path: str):
        self.config = Config.load(config_path)
        self.monitor = FileMonitor(self.config)
        self.analyzer = ImageAnalyzer(self.config)
        self.privacy_masker = PrivacyMasker(self.config)
        self.classifier = Classifier(self.config)
        self.database = Database(self.config)
        self.similar_detector = SimilarDetector(self.database)
        self.image_manager = ImageManager(self.config)
        self.notifier = Notifier(self.config)

    def start_monitoring(self):
        """ç›£è¦–ã‚’é–‹å§‹"""
        self.monitor.start(callback=self.process_screenshot)

    def process_screenshot(self, image_path: str):
        """ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆå‡¦ç†ã®ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼"""
        try:
            # 1. ç”»åƒè§£æ
            analysis_result = self.analyzer.analyze(image_path)

            # 2. å€‹äººæƒ…å ±ãƒã‚¹ã‚­ãƒ³ã‚°
            masked_result = self.privacy_masker.mask(analysis_result)

            # 3. åˆ†é¡
            category = self.classifier.classify(masked_result)

            # 4. é¡ä¼¼è³‡æ–™æ¤œå‡º
            similar_resources = self.similar_detector.find_similar(
                masked_result['keywords'],
                category
            )

            # 5. ãƒ‡ãƒ¼ã‚¿ä¿å­˜
            record_id = self.database.save(
                masked_result,
                category,
                similar_resources
            )

            # 6. é€šçŸ¥
            self.notifier.notify_completion(record_id, similar_resources)

            # 7. ç”»åƒç®¡ç†ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾…ã¡ï¼‰
            # ã“ã®æ®µéšã§ã¯ç”»åƒã¯ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ã•ã‚ŒãŸã¾ã¾

        except Exception as e:
            logging.error(f"å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            self.notifier.notify_error(image_path, str(e))

    def search(self, query: str, filters: dict) -> list:
        """æ¤œç´¢æ©Ÿèƒ½"""
        return self.database.search(query, filters)

    def init_database(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–"""
        self.database.initialize()
```

#### CLIã‚³ãƒãƒ³ãƒ‰

```python
import click

@click.group()
def cli():
    """åŒ»ç™‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆè‡ªå‹•æ•´ç†ã‚·ã‚¹ãƒ†ãƒ """
    pass

@cli.command()
@click.option('--config', default='config/config.yaml', help='è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹')
def start(config):
    """ç›£è¦–ã‚’é–‹å§‹"""
    app = MedScreenArchiver(config)
    app.start_monitoring()

@cli.command()
@click.option('--config', default='config/config.yaml', help='è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹')
def init(config):
    """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–"""
    app = MedScreenArchiver(config)
    app.init_database()

@cli.command()
@click.argument('query')
@click.option('--category', help='ã‚«ãƒ†ã‚´ãƒªçµã‚Šè¾¼ã¿')
@click.option('--from', 'from_date', help='é–‹å§‹æ—¥')
@click.option('--to', 'to_date', help='çµ‚äº†æ—¥')
@click.option('--show-related', is_flag=True, help='é¡ä¼¼è³‡æ–™ã‚’è¡¨ç¤º')
def search(query, category, from_date, to_date, show_related):
    """è³‡æ–™ã‚’æ¤œç´¢"""
    app = MedScreenArchiver('config/config.yaml')
    results = app.search(query, {
        'category': category,
        'from_date': from_date,
        'to_date': to_date,
        'show_related': show_related
    })
    # çµæœè¡¨ç¤ºå‡¦ç†
```

---

### 2.2 monitor.py - ãƒ•ã‚¡ã‚¤ãƒ«ç›£è¦–

#### è²¬å‹™
- ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆãƒ•ã‚©ãƒ«ãƒ€ã®ç›£è¦–
- æ–°è¦ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œçŸ¥
- é‡è¤‡æ¤œçŸ¥ã®é˜²æ­¢

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time
from pathlib import Path

class ScreenshotHandler(FileSystemEventHandler):
    """ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©"""

    def __init__(self, callback, wait_seconds=5):
        self.callback = callback
        self.wait_seconds = wait_seconds
        self.pending_files = {}  # {filepath: timestamp}

    def on_created(self, event):
        """ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚ã®ãƒãƒ³ãƒ‰ãƒ©"""
        if event.is_directory:
            return

        file_path = Path(event.src_path)

        # å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãƒã‚§ãƒƒã‚¯
        if file_path.suffix.lower() not in ['.png', '.jpg', '.jpeg']:
            return

        # å¾…æ©Ÿãƒªã‚¹ãƒˆã«è¿½åŠ 
        self.pending_files[str(file_path)] = time.time()

    def process_pending(self):
        """å¾…æ©Ÿä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†"""
        current_time = time.time()
        files_to_process = []

        for file_path, timestamp in list(self.pending_files.items()):
            if current_time - timestamp >= self.wait_seconds:
                files_to_process.append(file_path)
                del self.pending_files[file_path]

        for file_path in files_to_process:
            if Path(file_path).exists():
                self.callback(file_path)


class FileMonitor:
    """ãƒ•ã‚¡ã‚¤ãƒ«ç›£è¦–ã‚¯ãƒ©ã‚¹"""

    def __init__(self, config):
        self.watch_folder = Path(config['monitor']['watch_folder']).expanduser()
        self.wait_seconds = config['monitor']['wait_seconds']
        self.observer = None
        self.handler = None

    def start(self, callback):
        """ç›£è¦–é–‹å§‹"""
        self.handler = ScreenshotHandler(callback, self.wait_seconds)
        self.observer = Observer()
        self.observer.schedule(
            self.handler,
            str(self.watch_folder),
            recursive=False
        )
        self.observer.start()

        logging.info(f"ç›£è¦–é–‹å§‹: {self.watch_folder}")

        try:
            while True:
                time.sleep(1)
                self.handler.process_pending()
        except KeyboardInterrupt:
            self.stop()

    def stop(self):
        """ç›£è¦–åœæ­¢"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
        logging.info("ç›£è¦–åœæ­¢")
```

---

### 2.3 analyzer.py - ç”»åƒè§£æ

#### è²¬å‹™
- Claude APIã‚’ä½¿ã£ãŸç”»åƒè§£æ
- OCRï¼ˆæ–‡å­—èªè­˜ï¼‰
- å†…å®¹ç†è§£ã¨è¦ç´„
- å‡ºå…¸æƒ…å ±ã®æŠ½å‡º
- ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
import anthropic
from PIL import Image
import base64
from io import BytesIO
from pathlib import Path

class ImageAnalyzer:
    """ç”»åƒè§£æã‚¯ãƒ©ã‚¹"""

    def __init__(self, config):
        self.api_key = os.getenv('ANTHROPIC_API_KEY')
        self.client = anthropic.Anthropic(api_key=self.api_key)
        self.model = config['ai']['model']
        self.max_tokens = config['ai']['max_tokens']

    def _optimize_image(self, image_path: str, max_size: int = 1568) -> bytes:
        """ç”»åƒã‚’æœ€é©åŒ–ï¼ˆAPIé€ä¿¡ç”¨ï¼‰"""
        img = Image.open(image_path)

        # ã‚µã‚¤ã‚ºèª¿æ•´
        if max(img.size) > max_size:
            ratio = max_size / max(img.size)
            new_size = tuple(int(dim * ratio) for dim in img.size)
            img = img.resize(new_size, Image.LANCZOS)

        # PNGå½¢å¼ã§ãƒã‚¤ãƒˆåˆ—ã«å¤‰æ›
        buffer = BytesIO()
        img.save(buffer, format='PNG', optimize=True)
        return buffer.getvalue()

    def analyze(self, image_path: str) -> dict:
        """ç”»åƒã‚’è§£æ"""
        # ç”»åƒã‚’æœ€é©åŒ–
        image_data = self._optimize_image(image_path)
        image_base64 = base64.b64encode(image_data).decode('utf-8')

        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
        prompt = self._build_analysis_prompt()

        # Claude APIã§è§£æ
        message = self.client.messages.create(
            model=self.model,
            max_tokens=self.max_tokens,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": "image/png",
                                "data": image_base64,
                            },
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ],
                }
            ],
        )

        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹
        response_text = message.content[0].text
        result = self._parse_response(response_text)

        # å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¿½åŠ 
        result['original_image_path'] = image_path
        result['analyzed_at'] = datetime.now().isoformat()

        return result

    def _build_analysis_prompt(self) -> str:
        """è§£æç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        return """
ã“ã®åŒ»ç™‚é–¢é€£ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆç”»åƒã‚’è§£æã—ã¦ãã ã•ã„ã€‚

ä»¥ä¸‹ã®æƒ…å ±ã‚’æŠ½å‡ºã—ã€JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ï¼š

{
  "title": "ç”»åƒã®ä¸»é¡Œãƒ»ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆ50æ–‡å­—ä»¥å†…ï¼‰",
  "summary": "å†…å®¹ã®è¦ç´„ï¼ˆ200æ–‡å­—ä»¥å†…ï¼‰",
  "full_text": "ç”»åƒå†…ã®å…¨æ–‡å­—æƒ…å ±ï¼ˆOCRçµæœï¼‰",
  "keywords": ["ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰1", "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰2", ...],
  "medical_terms": {
    "diseases": ["ç–¾æ‚£å1", "ç–¾æ‚£å2", ...],
    "treatments": ["æ²»ç™‚æ³•1", "æ²»ç™‚æ³•2", ...],
    "drugs": ["è–¬å‰¤å1", "è–¬å‰¤å2", ...]
  },
  "source": {
    "type": "å­¦ä¼š or è«–æ–‡ or æ•™ç§‘æ›¸ or ãã®ä»–",
    "conference_name": "å­¦ä¼šåï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰",
    "paper_title": "è«–æ–‡ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰",
    "authors": ["è‘—è€…1", "è‘—è€…2", ...],
    "year": "ç™ºè¡¨å¹´ãƒ»å‡ºç‰ˆå¹´ï¼ˆYYYYå½¢å¼ï¼‰",
    "source_text": "å‡ºå…¸æƒ…å ±ã®å…ƒãƒ†ã‚­ã‚¹ãƒˆ"
  },
  "case_info": {
    "has_case": true/false,
    "gender": "ç”·æ€§ or å¥³æ€§ or ä¸æ˜",
    "age": "å¹´é½¢ï¼ˆæ•°å€¤ã¾ãŸã¯ç¯„å›²ã€ä¾‹: 65 or 60-70ï¼‰",
    "patient_identifiers": ["æ¤œå‡ºã•ã‚ŒãŸå€‹äººè­˜åˆ¥æƒ…å ±ã®ãƒªã‚¹ãƒˆ"]
  },
  "visual_elements": {
    "has_chart": true/false,
    "has_graph": true/false,
    "has_image": true/false,
    "has_diagram": true/false,
    "description": "å›³è¡¨ãƒ»ç”»åƒã®èª¬æ˜ï¼ˆãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã§ã¯ä¸ååˆ†ãªå ´åˆï¼‰"
  },
  "category_suggestion": "æœ€ã‚‚é©åˆ‡ãªã‚«ãƒ†ã‚´ãƒªã®æ¨å®šï¼ˆå©¦äººç§‘/GSMé–¢é€£ã€å©¦äººç§‘/éª¨ç›¤è‡“å™¨è„±ã€ãªã©ï¼‰"
}

é‡è¦ï¼š
- æ‚£è€…å€‹äººæƒ…å ±ï¼ˆæ°åã€ç”Ÿå¹´æœˆæ—¥ã€IDï¼‰ã‚’æ¤œå‡ºã—ãŸå ´åˆã¯ã€case_info.patient_identifiers ã«è¨˜éŒ²ã—ã¦ãã ã•ã„
- æ€§åˆ¥ã¨å¹´é½¢ã®ã¿ã‚’ä¿æŒã—ã¾ã™
- åŒ»å­¦ç”¨èªã¯æ­£ç¢ºã«æŠ½å‡ºã—ã¦ãã ã•ã„
- å‡ºå…¸æƒ…å ±ãŒãªã„å ´åˆã¯ null ã‚’è¿”ã—ã¦ãã ã•ã„
"""

    def _parse_response(self, response_text: str) -> dict:
        """Claude APIã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ‘ãƒ¼ã‚¹"""
        import json
        import re

        # JSONãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
        json_match = re.search(r'```json\s*(\{.*?\})\s*```', response_text, re.DOTALL)
        if json_match:
            json_str = json_match.group(1)
        else:
            # ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãªã—ã®å ´åˆ
            json_str = response_text.strip()

        try:
            return json.loads(json_str)
        except json.JSONDecodeError as e:
            logging.error(f"JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: {e}")
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€ä½é™ã®æ§‹é€ ã‚’è¿”ã™
            return {
                "title": "è§£æã‚¨ãƒ©ãƒ¼",
                "summary": response_text[:200],
                "full_text": response_text,
                "keywords": [],
                "error": str(e)
            }
```

---

### 2.4 privacy.py - å€‹äººæƒ…å ±ãƒã‚¹ã‚­ãƒ³ã‚°

#### è²¬å‹™
- å€‹äººè­˜åˆ¥æƒ…å ±ã®æ¤œå‡ºã¨å‰Šé™¤
- æ€§åˆ¥ãƒ»å¹´é½¢ã®ã¿ã‚’ä¿æŒ
- ãƒã‚¹ã‚­ãƒ³ã‚°çµæœã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆ

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
import re
from typing import Dict, List

class PrivacyMasker:
    """å€‹äººæƒ…å ±ãƒã‚¹ã‚­ãƒ³ã‚°ã‚¯ãƒ©ã‚¹"""

    def __init__(self, config):
        self.config = config
        # å€‹äººæƒ…å ±æ¤œå‡ºãƒ‘ã‚¿ãƒ¼ãƒ³
        self.patterns = {
            'name': [
                r'æ‚£è€…å[:ï¼š\s]*([^\s\n]+)',
                r'æ°å[:ï¼š\s]*([^\s\n]+)',
                r'Name[:ï¼š\s]*([A-Za-z\s]+)',
            ],
            'patient_id': [
                r'æ‚£è€…ID[:ï¼š\s]*([0-9A-Z\-]+)',
                r'ID[:ï¼š\s]*([0-9A-Z\-]+)',
                r'ã‚«ãƒ«ãƒ†ç•ªå·[:ï¼š\s]*([0-9\-]+)',
            ],
            'birth_date': [
                r'ç”Ÿå¹´æœˆæ—¥[:ï¼š\s]*(\d{4}[å¹´/\-]\d{1,2}[æœˆ/\-]\d{1,2}æ—¥?)',
                r'DOB[:ï¼š\s]*(\d{4}[/\-]\d{1,2}[/\-]\d{1,2})',
            ],
        }

    def mask(self, analysis_result: dict) -> dict:
        """å€‹äººæƒ…å ±ã‚’ãƒã‚¹ã‚­ãƒ³ã‚°"""
        masked_result = analysis_result.copy()

        # AIãŒæ¤œå‡ºã—ãŸå€‹äººè­˜åˆ¥æƒ…å ±
        patient_identifiers = analysis_result.get('case_info', {}).get('patient_identifiers', [])

        # ãƒ•ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ãƒã‚¹ã‚­ãƒ³ã‚°
        full_text = analysis_result.get('full_text', '')
        masked_text = self._mask_text(full_text, patient_identifiers)
        masked_result['full_text'] = masked_text

        # ã‚µãƒãƒªãƒ¼ã‹ã‚‰ã‚‚ãƒã‚¹ã‚­ãƒ³ã‚°
        summary = analysis_result.get('summary', '')
        masked_summary = self._mask_text(summary, patient_identifiers)
        masked_result['summary'] = masked_summary

        # æ€§åˆ¥ãƒ»å¹´é½¢ã®ã¿ä¿æŒ
        case_info = analysis_result.get('case_info', {})
        masked_result['case_info'] = {
            'gender': case_info.get('gender', 'ä¸æ˜'),
            'age': case_info.get('age', 'ä¸æ˜'),
        }

        # ãƒã‚¹ã‚­ãƒ³ã‚°ãƒ­ã‚°
        masked_result['privacy_masked'] = {
            'masked_count': len(patient_identifiers),
            'identifiers_removed': patient_identifiers,  # ãƒ‡ãƒãƒƒã‚°ç”¨ï¼ˆæœ¬ç•ªã§ã¯å‰Šé™¤æ¨å¥¨ï¼‰
            'masked_at': datetime.now().isoformat()
        }

        return masked_result

    def _mask_text(self, text: str, identifiers: List[str]) -> str:
        """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰å€‹äººæƒ…å ±ã‚’ãƒã‚¹ã‚­ãƒ³ã‚°"""
        masked_text = text

        # AIãŒæ¤œå‡ºã—ãŸè­˜åˆ¥æƒ…å ±ã‚’å‰Šé™¤
        for identifier in identifiers:
            # å®Œå…¨ä¸€è‡´ã§ç½®æ›
            masked_text = masked_text.replace(identifier, '[å€‹äººæƒ…å ±å‰Šé™¤]')

        # ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã§è¿½åŠ æ¤œå‡º
        for pattern_type, patterns in self.patterns.items():
            for pattern in patterns:
                masked_text = re.sub(pattern, f'[{pattern_type}å‰Šé™¤]', masked_text)

        return masked_text

    def preview_masking(self, original_text: str, masked_text: str) -> dict:
        """ãƒã‚¹ã‚­ãƒ³ã‚°å‰å¾Œã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼"""
        return {
            'original': original_text,
            'masked': masked_text,
            'diff': self._generate_diff(original_text, masked_text)
        }

    def _generate_diff(self, original: str, masked: str) -> List[dict]:
        """å·®åˆ†ã‚’ç”Ÿæˆ"""
        # ç°¡æ˜“çš„ãªå·®åˆ†è¡¨ç¤º
        import difflib

        diff = []
        matcher = difflib.SequenceMatcher(None, original, masked)

        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'replace':
                diff.append({
                    'type': 'masked',
                    'original': original[i1:i2],
                    'masked': masked[j1:j2]
                })

        return diff
```

---

### 2.5 classifier.py - è‡ªå‹•åˆ†é¡

#### è²¬å‹™
- è§£æçµæœã‹ã‚‰ã‚«ãƒ†ã‚´ãƒªã‚’åˆ¤å®š
- åŒ»å­¦ç”¨èªè¾æ›¸ã‚’å‚ç…§
- ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ã®ç®¡ç†

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
from pathlib import Path
import json

class Classifier:
    """è‡ªå‹•åˆ†é¡ã‚¯ãƒ©ã‚¹"""

    def __init__(self, config):
        self.config = config
        self.categories = config['classification']['categories']
        self.base_folder = Path(config['storage']['base_folder']).expanduser()

        # åŒ»å­¦ç”¨èªè¾æ›¸ã‚’èª­ã¿è¾¼ã¿
        terms_path = Path('data/medical_terms.json')
        if terms_path.exists():
            with open(terms_path, 'r', encoding='utf-8') as f:
                self.medical_terms = json.load(f)
        else:
            self.medical_terms = {}

    def classify(self, analysis_result: dict) -> str:
        """ã‚«ãƒ†ã‚´ãƒªã‚’åˆ¤å®š"""
        # AIã®æ¨å®šã‚«ãƒ†ã‚´ãƒªã‚’å„ªå…ˆ
        suggested_category = analysis_result.get('category_suggestion')
        if suggested_category and suggested_category in self.categories:
            return suggested_category

        # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰åˆ¤å®š
        keywords = analysis_result.get('keywords', [])
        medical_terms = analysis_result.get('medical_terms', {})

        category = self._match_category(keywords, medical_terms)

        return category if category else 'æœªåˆ†é¡'

    def _match_category(self, keywords: List[str], medical_terms: dict) -> str:
        """ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ã‚«ãƒ†ã‚´ãƒªã‚’ãƒãƒƒãƒãƒ³ã‚°"""
        # ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
        scores = {category: 0 for category in self.categories}

        # ã‚«ãƒ†ã‚´ãƒªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆè¨­å®šã‹ã‚‰å–å¾—ã¾ãŸã¯å®šç¾©ï¼‰
        category_keywords = {
            'å©¦äººç§‘/GSMé–¢é€£': ['GSM', 'èç¸®æ€§è…Ÿç‚', 'ã‚¨ã‚¹ãƒˆãƒ­ã‚²ãƒ³', 'é–‰çµŒå¾Œ'],
            'å©¦äººç§‘/éª¨ç›¤è‡“å™¨è„±': ['éª¨ç›¤è‡“å™¨è„±', 'POP', 'å­å®®è„±', 'è†€èƒ±ç˜¤'],
            'å©¦äººç§‘/æ›´å¹´æœŸéšœå®³': ['æ›´å¹´æœŸ', 'HRT', 'ãƒ›ãƒ«ãƒ¢ãƒ³è£œå……ç™‚æ³•'],
            'ç”£ç§‘': ['å¦Šå¨ ', 'å‡ºç”£', 'åˆ†å¨©'],
            'æ³Œå°¿å™¨ç§‘': ['æ’å°¿éšœå®³', 'å°¿å¤±ç¦', 'éæ´»å‹•è†€èƒ±'],
        }

        # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒãƒ³ã‚°
        for category, category_kws in category_keywords.items():
            for kw in keywords:
                if any(ckw in kw or kw in ckw for ckw in category_kws):
                    scores[category] += 2

        # ç–¾æ‚£åãƒãƒƒãƒãƒ³ã‚°
        for disease in medical_terms.get('diseases', []):
            for category, category_kws in category_keywords.items():
                if any(ckw in disease for ckw in category_kws):
                    scores[category] += 3

        # æœ€é«˜ã‚¹ã‚³ã‚¢ã®ã‚«ãƒ†ã‚´ãƒªã‚’è¿”ã™
        if max(scores.values()) > 0:
            return max(scores, key=scores.get)

        return None

    def get_save_path(self, category: str, title: str, timestamp: datetime) -> Path:
        """ä¿å­˜ãƒ‘ã‚¹ã‚’å–å¾—"""
        # ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚©ãƒ«ãƒ€
        category_folder = self.base_folder / category
        category_folder.mkdir(parents=True, exist_ok=True)

        # ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆï¼ˆæ—¥ä»˜ + ã‚¿ã‚¤ãƒˆãƒ«ï¼‰
        date_str = timestamp.strftime('%Y%m%d')
        safe_title = self._sanitize_filename(title)
        filename = f"{date_str}_{safe_title}.md"

        # é‡è¤‡ãƒã‚§ãƒƒã‚¯
        filepath = category_folder / filename
        counter = 1
        while filepath.exists():
            filename = f"{date_str}_{safe_title}_{counter}.md"
            filepath = category_folder / filename
            counter += 1

        return filepath

    def _sanitize_filename(self, title: str, max_length: int = 50) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚º"""
        # ä½¿ç”¨ä¸å¯æ–‡å­—ã‚’å‰Šé™¤
        sanitized = re.sub(r'[\\/:*?"<>|]', '', title)
        # é•·ã•åˆ¶é™
        if len(sanitized) > max_length:
            sanitized = sanitized[:max_length]
        return sanitized.strip()
```

---

### 2.6 database.py - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œ

#### è²¬å‹™
- SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ç®¡ç†
- Markdownãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ
- ãƒ•ãƒ«ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢
- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ¤œç´¢

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
import sqlite3
from pathlib import Path
from datetime import datetime
import json

class Database:
    """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†ã‚¯ãƒ©ã‚¹"""

    def __init__(self, config):
        self.config = config
        self.base_folder = Path(config['storage']['base_folder']).expanduser()
        self.db_path = self.base_folder / 'screenshots.db'

    def initialize(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–"""
        self.base_folder.mkdir(parents=True, exist_ok=True)

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # ãƒ¡ã‚¤ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS screenshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                file_path TEXT NOT NULL,
                md_path TEXT NOT NULL,
                image_path TEXT,
                created_at DATETIME NOT NULL,
                category TEXT,
                keywords TEXT,
                source_info TEXT,
                case_info TEXT,
                summary TEXT,
                needs_review BOOLEAN DEFAULT 0,
                has_similar_old BOOLEAN DEFAULT 0,
                last_updated DATETIME
            )
        ''')

        # å…¨æ–‡æ¤œç´¢ãƒ†ãƒ¼ãƒ–ãƒ«
        cursor.execute('''
            CREATE VIRTUAL TABLE IF NOT EXISTS screenshots_fts
            USING fts5(
                content,
                tokenize = 'unicode61'
            )
        ''')

        conn.commit()
        conn.close()

        logging.info(f"ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–å®Œäº†: {self.db_path}")

    def save(self, analysis_result: dict, category: str,
             similar_resources: List[dict]) -> int:
        """è§£æçµæœã‚’ä¿å­˜"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Markdownãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ
        classifier = Classifier(self.config)
        md_path = classifier.get_save_path(
            category,
            analysis_result['title'],
            datetime.now()
        )

        md_content = self._generate_markdown(
            analysis_result,
            category,
            similar_resources
        )

        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(md_content)

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
        cursor.execute('''
            INSERT INTO screenshots (
                file_path, md_path, image_path, created_at, category,
                keywords, source_info, case_info, summary,
                has_similar_old, last_updated
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            analysis_result['original_image_path'],
            str(md_path),
            None,  # ç”»åƒã¯å¾Œã§æ‰‹å‹•ã§ä¿å­˜
            datetime.now().isoformat(),
            category,
            json.dumps(analysis_result.get('keywords', []), ensure_ascii=False),
            json.dumps(analysis_result.get('source', {}), ensure_ascii=False),
            json.dumps(analysis_result.get('case_info', {}), ensure_ascii=False),
            analysis_result.get('summary', ''),
            len(similar_resources) > 0,
            datetime.now().isoformat()
        ))

        record_id = cursor.lastrowid

        # å…¨æ–‡æ¤œç´¢ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ 
        cursor.execute('''
            INSERT INTO screenshots_fts (rowid, content)
            VALUES (?, ?)
        ''', (
            record_id,
            analysis_result.get('full_text', '')
        ))

        conn.commit()
        conn.close()

        logging.info(f"ä¿å­˜å®Œäº†: {md_path} (ID: {record_id})")

        return record_id

    def _generate_markdown(self, analysis_result: dict, category: str,
                          similar_resources: List[dict]) -> str:
        """Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ"""
        # é¡ä¼¼è³‡æ–™ã‚»ã‚¯ã‚·ãƒ§ãƒ³
        similar_section = ""
        if similar_resources:
            similar_section = "\n---\nğŸ“š **åŒã˜ãƒˆãƒ”ãƒƒã‚¯ã®éå»è³‡æ–™ãŒã‚ã‚Šã¾ã™**\n\n"
            for res in similar_resources:
                res_date = datetime.fromisoformat(res['created_at']).strftime('%Yå¹´%mæœˆ')
                rel_path = Path(res['md_path']).relative_to(Path(res['md_path']).parent.parent)
                similar_section += f"- [{res['title']}](../{rel_path}) ({res_date})\n"
            similar_section += "- æœ€æ–°ã®çŸ¥è¦‹ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™\n---\n"

        # ã‚½ãƒ¼ã‚¹æƒ…å ±
        source = analysis_result.get('source', {})
        source_text = "ä¸æ˜"
        if source and source.get('type'):
            if source['type'] == 'å­¦ä¼š':
                source_text = f"{source.get('conference_name', '')} ({source.get('year', '')})"
            elif source['type'] == 'è«–æ–‡':
                source_text = f"{source.get('paper_title', '')} ({source.get('year', '')})"
            else:
                source_text = source.get('source_text', 'ä¸æ˜')

        # ç—‡ä¾‹æƒ…å ±
        case_info = analysis_result.get('case_info', {})
        case_text = f"{case_info.get('gender', 'ä¸æ˜')}ã€{case_info.get('age', 'ä¸æ˜')}æ­³"

        # Markdownæ§‹ç¯‰
        md_content = f"""# {analysis_result.get('title', 'ç„¡é¡Œ')}

**å–å¾—æ—¥æ™‚**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**ã‚«ãƒ†ã‚´ãƒª**: {category}
**å‡ºå…¸**: {source_text}
**ç—‡ä¾‹æƒ…å ±**: {case_text}
**ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰**: {' '.join(['#' + kw for kw in analysis_result.get('keywords', [])])}
**ç”»åƒä¿å­˜**: ãªã—

{similar_section}

## è¦ç´„

{analysis_result.get('summary', '')}

---

## å†…å®¹

{analysis_result.get('full_text', '')}

---

## è¦–è¦šè¦ç´ 

{analysis_result.get('visual_elements', {}).get('description', 'ç‰¹ã«ãªã—')}

---

## ãƒ¡ãƒ¢

<!-- ã“ã“ã«æ‰‹å‹•ã§ãƒ¡ãƒ¢ã‚’è¿½è¨˜ã§ãã¾ã™ -->

"""

        return md_content

    def search(self, query: str, filters: dict) -> List[dict]:
        """æ¤œç´¢"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        # ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒª
        sql = """
            SELECT s.*, fts.content
            FROM screenshots s
            LEFT JOIN screenshots_fts fts ON s.id = fts.rowid
            WHERE 1=1
        """
        params = []

        # ãƒ•ãƒ«ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢
        if query:
            sql += " AND fts.content MATCH ?"
            params.append(query)

        # ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿
        if filters.get('category'):
            sql += " AND s.category = ?"
            params.append(filters['category'])

        # æ—¥ä»˜ç¯„å›²ãƒ•ã‚£ãƒ«ã‚¿
        if filters.get('from_date'):
            sql += " AND s.created_at >= ?"
            params.append(filters['from_date'])

        if filters.get('to_date'):
            sql += " AND s.created_at <= ?"
            params.append(filters['to_date'])

        # è¦ç¢ºèªãƒ•ãƒ©ã‚°
        if filters.get('needs_review'):
            sql += " AND s.needs_review = 1"

        # ä¸¦ã³é †
        sql += " ORDER BY s.created_at DESC"

        cursor.execute(sql, params)
        results = [dict(row) for row in cursor.fetchall()]

        conn.close()

        return results

    def update_image_path(self, record_id: int, image_path: str):
        """ç”»åƒãƒ‘ã‚¹ã‚’æ›´æ–°"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            UPDATE screenshots
            SET image_path = ?, last_updated = ?
            WHERE id = ?
        ''', (image_path, datetime.now().isoformat(), record_id))

        # Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‚‚æ›´æ–°
        cursor.execute('SELECT md_path FROM screenshots WHERE id = ?', (record_id,))
        md_path = cursor.fetchone()[0]

        with open(md_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # ç”»åƒä¿å­˜ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        content = content.replace('**ç”»åƒä¿å­˜**: ãªã—', '**ç”»åƒä¿å­˜**: ã‚ã‚Š')

        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(content)

        conn.commit()
        conn.close()
```

---

### 2.7 similar_detector.py - é¡ä¼¼è³‡æ–™æ¤œå‡º

#### è²¬å‹™
- åŒä¸€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å¤ã„è³‡æ–™ã‚’æ¤œå‡º
- é–¢é€£è³‡æ–™ã®ãƒªãƒ³ã‚¯ç”Ÿæˆ

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
from datetime import datetime, timedelta
import json

class SimilarDetector:
    """é¡ä¼¼è³‡æ–™æ¤œå‡ºã‚¯ãƒ©ã‚¹"""

    def __init__(self, database: Database, threshold_months: int = 12):
        self.database = database
        self.threshold_months = threshold_months

    def find_similar(self, keywords: List[str], category: str) -> List[dict]:
        """é¡ä¼¼è³‡æ–™ã‚’æ¤œç´¢"""
        if not keywords:
            return []

        conn = sqlite3.connect(self.database.db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        # ã—ãã„å€¤æ—¥ä»˜ã‚’è¨ˆç®—
        threshold_date = datetime.now() - timedelta(days=self.threshold_months * 30)

        similar_resources = []

        # å„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§æ¤œç´¢
        for keyword in keywords:
            cursor.execute('''
                SELECT id, md_path, category, keywords, summary, created_at
                FROM screenshots
                WHERE category = ?
                  AND created_at < ?
                  AND keywords LIKE ?
            ''', (category, threshold_date.isoformat(), f'%{keyword}%'))

            results = cursor.fetchall()

            for row in results:
                # é‡è¤‡ãƒã‚§ãƒƒã‚¯
                if not any(r['id'] == row['id'] for r in similar_resources):
                    similar_resources.append({
                        'id': row['id'],
                        'md_path': row['md_path'],
                        'title': self._extract_title_from_md(row['md_path']),
                        'created_at': row['created_at'],
                        'matched_keyword': keyword
                    })

        conn.close()

        # æ—¥ä»˜ã§ã‚½ãƒ¼ãƒˆï¼ˆå¤ã„é †ï¼‰
        similar_resources.sort(key=lambda x: x['created_at'])

        return similar_resources

    def _extract_title_from_md(self, md_path: str) -> str:
        """Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡º"""
        try:
            with open(md_path, 'r', encoding='utf-8') as f:
                first_line = f.readline().strip()
                if first_line.startswith('# '):
                    return first_line[2:]
        except:
            pass
        return Path(md_path).stem
```

---

### 2.8 image_manager.py - ç”»åƒç®¡ç†

#### è²¬å‹™
- ç”»åƒã®ä¿å­˜ãƒ»å‰Šé™¤ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
- ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã¸ã®ç§»å‹•

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
import shutil
from pathlib import Path

class ImageManager:
    """ç”»åƒç®¡ç†ã‚¯ãƒ©ã‚¹"""

    def __init__(self, config):
        self.config = config
        self.temp_folder = Path(config['storage']['temp_folder']).expanduser()
        self.archive_folder = Path(config['storage']['base_folder']).expanduser() / '_archives' / 'images'

        # ãƒ•ã‚©ãƒ«ãƒ€ä½œæˆ
        self.temp_folder.mkdir(parents=True, exist_ok=True)
        self.archive_folder.mkdir(parents=True, exist_ok=True)

    def move_to_temp(self, image_path: str) -> str:
        """ç”»åƒã‚’ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€ã«ç§»å‹•"""
        src = Path(image_path)
        dst = self.temp_folder / src.name

        # é‡è¤‡å›é¿
        counter = 1
        while dst.exists():
            dst = self.temp_folder / f"{src.stem}_{counter}{src.suffix}"
            counter += 1

        shutil.move(str(src), str(dst))

        logging.info(f"ä¸€æ™‚ä¿å­˜: {dst}")

        return str(dst)

    def save_to_archive(self, temp_image_path: str, record_id: int) -> str:
        """ç”»åƒã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ä¿å­˜"""
        src = Path(temp_image_path)

        # ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆrecord_idã‚’å«ã‚€ï¼‰
        dst = self.archive_folder / f"{record_id}_{src.name}"

        shutil.move(str(src), str(dst))

        logging.info(f"ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ä¿å­˜: {dst}")

        return str(dst)

    def delete_temp_image(self, temp_image_path: str):
        """ä¸€æ™‚ç”»åƒã‚’å‰Šé™¤"""
        path = Path(temp_image_path)
        if path.exists():
            path.unlink()
            logging.info(f"ç”»åƒå‰Šé™¤: {temp_image_path}")

    def list_temp_images(self) -> List[dict]:
        """ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€ã®ç”»åƒãƒªã‚¹ãƒˆ"""
        images = []
        for img_path in self.temp_folder.glob('*'):
            if img_path.suffix.lower() in ['.png', '.jpg', '.jpeg']:
                images.append({
                    'path': str(img_path),
                    'name': img_path.name,
                    'size': img_path.stat().st_size,
                    'created': datetime.fromtimestamp(img_path.stat().st_ctime)
                })

        return sorted(images, key=lambda x: x['created'], reverse=True)
```

---

### 2.9 utils.py - ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

#### è²¬å‹™
- å…±é€šå‡¦ç†
- é€šçŸ¥æ©Ÿèƒ½
- ãƒ­ã‚®ãƒ³ã‚°è¨­å®š

#### ã‚¯ãƒ©ã‚¹è¨­è¨ˆ

```python
import logging
import subprocess
from pathlib import Path

class Notifier:
    """é€šçŸ¥ã‚¯ãƒ©ã‚¹"""

    def __init__(self, config):
        self.enabled = config['notification']['enabled']
        self.method = config['notification']['method']

    def notify_completion(self, record_id: int, similar_resources: List[dict]):
        """å‡¦ç†å®Œäº†é€šçŸ¥"""
        if not self.enabled:
            return

        title = "ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆè§£æå®Œäº†"

        if similar_resources:
            message = f"ID: {record_id}\né¡ä¼¼è³‡æ–™ãŒ {len(similar_resources)} ä»¶è¦‹ã¤ã‹ã‚Šã¾ã—ãŸ"
        else:
            message = f"ID: {record_id}\næ–°è¦è³‡æ–™ã¨ã—ã¦ä¿å­˜ã•ã‚Œã¾ã—ãŸ"

        self._send_notification(title, message)

    def notify_error(self, image_path: str, error: str):
        """ã‚¨ãƒ©ãƒ¼é€šçŸ¥"""
        if not self.enabled:
            return

        title = "è§£æã‚¨ãƒ©ãƒ¼"
        message = f"{Path(image_path).name}\n{error}"

        self._send_notification(title, message)

    def _send_notification(self, title: str, message: str):
        """macOSé€šçŸ¥ã‚’é€ä¿¡"""
        if self.method == 'macos':
            subprocess.run([
                'osascript', '-e',
                f'display notification "{message}" with title "{title}"'
            ])

        # ãƒ­ã‚°ã«ã‚‚è¨˜éŒ²
        logging.info(f"é€šçŸ¥: {title} - {message}")


class Config:
    """è¨­å®šç®¡ç†ã‚¯ãƒ©ã‚¹"""

    @staticmethod
    def load(config_path: str) -> dict:
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿"""
        import yaml

        with open(config_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)

        return config


def setup_logging(log_dir: str = 'logs'):
    """ãƒ­ã‚®ãƒ³ã‚°è¨­å®š"""
    Path(log_dir).mkdir(exist_ok=True)

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(f'{log_dir}/medscreen_{datetime.now().strftime("%Y%m%d")}.log'),
            logging.StreamHandler()
        ]
    )
```

---

## 3. ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

### 3.1 è§£æçµæœãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```python
{
    "title": str,                    # ã‚¿ã‚¤ãƒˆãƒ«
    "summary": str,                  # è¦ç´„
    "full_text": str,                # å…¨æ–‡ï¼ˆãƒã‚¹ã‚­ãƒ³ã‚°æ¸ˆã¿ï¼‰
    "keywords": List[str],           # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    "medical_terms": {
        "diseases": List[str],
        "treatments": List[str],
        "drugs": List[str]
    },
    "source": {
        "type": str,                 # å­¦ä¼š/è«–æ–‡/æ•™ç§‘æ›¸/ãã®ä»–
        "conference_name": str,
        "paper_title": str,
        "authors": List[str],
        "year": str,
        "source_text": str
    },
    "case_info": {
        "gender": str,               # æ€§åˆ¥ã®ã¿
        "age": str                   # å¹´é½¢ã®ã¿
    },
    "visual_elements": {
        "has_chart": bool,
        "has_graph": bool,
        "has_image": bool,
        "has_diagram": bool,
        "description": str
    },
    "category_suggestion": str,
    "original_image_path": str,
    "analyzed_at": str,
    "privacy_masked": {
        "masked_count": int,
        "masked_at": str
    }
}
```

---

## 4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### 4.1 ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥ã¨å¯¾å¿œ

| ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥ | å¯¾å¿œ |
|-----------|------|
| API ã‚¨ãƒ©ãƒ¼ | ãƒªãƒˆãƒ©ã‚¤ï¼ˆæœ€å¤§3å›ï¼‰â†’ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ã«ä¿å­˜ |
| ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ | ãƒ­ã‚°è¨˜éŒ² â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼é€šçŸ¥ â†’ ã‚¹ã‚­ãƒƒãƒ— |
| ãƒ‘ãƒ¼ã‚¹ ã‚¨ãƒ©ãƒ¼ | ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç† â†’ æœ€ä½é™ã®ãƒ‡ãƒ¼ã‚¿ã§ä¿å­˜ |
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ ã‚¨ãƒ©ãƒ¼ | ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ â†’ ãƒ­ã‚°è¨˜éŒ² |
| å€‹äººæƒ…å ±æ¤œå‡ºå¤±æ•— | è­¦å‘Šè¡¨ç¤º â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèªã‚’ä¿ƒã™ |

### 4.2 ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥

```python
from tenacity import retry, stop_after_attempt, wait_exponential

class ImageAnalyzer:

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10)
    )
    def analyze(self, image_path: str) -> dict:
        """ç”»åƒã‚’è§£æï¼ˆãƒªãƒˆãƒ©ã‚¤ä»˜ãï¼‰"""
        # ... è§£æå‡¦ç†
```

---

## 5. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

### 5.1 API ã‚­ãƒ¼ç®¡ç†

- ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èª­ã¿è¾¼ã¿: `ANTHROPIC_API_KEY`
- macOS Keychainã¸ã®ä¿å­˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³æä¾›
- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯è¨˜è¼‰ã—ãªã„

### 5.2 å€‹äººæƒ…å ±ä¿è­·

- AI + ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã®äºŒæ®µéšæ¤œå‡º
- ãƒã‚¹ã‚­ãƒ³ã‚°å‰å¾Œã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹æœ€çµ‚ç¢ºèª
- ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯å€‹äººæƒ…å ±ã‚’è¨˜éŒ²ã—ãªã„

### 5.3 ãƒ‡ãƒ¼ã‚¿ä¿å­˜

- ãƒ­ãƒ¼ã‚«ãƒ«å‡¦ç†ã‚’åŸºæœ¬
- Claude APIã«ã¯æœ€å°é™ã®æƒ…å ±ã®ã¿é€ä¿¡
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯æš—å·åŒ–ã‚ªãƒ—ã‚·ãƒ§ãƒ³æä¾›ï¼ˆå°†æ¥æ‹¡å¼µï¼‰

---

## 6. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 6.1 ç”»åƒå‡¦ç†

- Claude APIé€ä¿¡å‰ã«ç”»åƒã‚µã‚¤ã‚ºã‚’æœ€é©åŒ–ï¼ˆæœ€å¤§1568pxï¼‰
- PNGå½¢å¼ã§åœ§ç¸®

### 6.2 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹

- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆï¼ˆcategory, created_at, keywordsï¼‰
- å…¨æ–‡æ¤œç´¢ã¯FTS5ã‚’ä½¿ç”¨
- å®šæœŸçš„ãªVACUUMå®Ÿè¡Œ

### 6.3 éåŒæœŸå‡¦ç†ï¼ˆå°†æ¥æ‹¡å¼µï¼‰

- è¤‡æ•°ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®åŒæ™‚å‡¦ç†
- asyncioã«ã‚ˆã‚‹ä¸¦åˆ—åŒ–

---

## 7. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### 7.1 å˜ä½“ãƒ†ã‚¹ãƒˆ

- å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã”ã¨ã«ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ
- pytestä½¿ç”¨
- ã‚«ãƒãƒ¬ãƒƒã‚¸80%ä»¥ä¸Šã‚’ç›®æ¨™

### 7.2 çµ±åˆãƒ†ã‚¹ãƒˆ

- ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã®å‡¦ç†ãƒ•ãƒ­ãƒ¼ç¢ºèª
- ãƒ¢ãƒƒã‚¯APIä½¿ç”¨ã§Claude APIå‘¼ã³å‡ºã—ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ

### 7.3 å€‹äººæƒ…å ±ãƒã‚¹ã‚­ãƒ³ã‚°ãƒ†ã‚¹ãƒˆ

- ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆä½œæˆï¼ˆæ¶ç©ºã®æ‚£è€…æƒ…å ±ï¼‰
- ãƒã‚¹ã‚­ãƒ³ã‚°æ¼ã‚Œã®æ¤œè¨¼
- False Positiveï¼ˆéå‰°ãƒã‚¹ã‚­ãƒ³ã‚°ï¼‰ã®æ¤œè¨¼

---

## 8. ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ

### 8.1 ç’°å¢ƒæ§‹ç¯‰

```bash
# 1. ãƒªãƒã‚¸ãƒˆãƒªã‚¯ãƒ­ãƒ¼ãƒ³
git clone <repository-url>
cd medical-screenshot-archiver

# 2. ä»®æƒ³ç’°å¢ƒä½œæˆ
python3 -m venv venv
source venv/bin/activate

# 3. ä¾å­˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pip install -r requirements.txt

# 4. ç’°å¢ƒå¤‰æ•°è¨­å®š
export ANTHROPIC_API_KEY="your-api-key"

# 5. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ç·¨é›†
cp config/config.yaml.example config/config.yaml
vim config/config.yaml

# 6. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
python src/main.py init

# 7. ç›£è¦–é–‹å§‹
python src/main.py start
```

### 8.2 ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å®Ÿè¡Œ

launchdã‚’ä½¿ç”¨ã—ã¦macOSã§è‡ªå‹•èµ·å‹•

```xml
<!-- ~/Library/LaunchAgents/com.medscreen.archiver.plist -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.medscreen.archiver</string>
    <key>ProgramArguments</key>
    <array>
        <string>/path/to/venv/bin/python</string>
        <string>/path/to/src/main.py</string>
        <string>start</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>
```

---

## 9. ä»Šå¾Œã®æ‹¡å¼µæ¡ˆ

### 9.1 Web UI

- Flask/FastAPI ã«ã‚ˆã‚‹Web ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
- ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰

### 9.2 ã‚¯ãƒ©ã‚¦ãƒ‰é€£æº

- iCloud Drive/Dropboxã¸ã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
- ãƒãƒ¼ãƒ å…±æœ‰æ©Ÿèƒ½

### 9.3 AIæ©Ÿèƒ½å¼·åŒ–

- è‡ªå‹•è¦ç´„ã®ç²¾åº¦å‘ä¸Š
- é¡ä¼¼åº¦è¨ˆç®—ã®é«˜åº¦åŒ–ï¼ˆåŸ‹ã‚è¾¼ã¿ãƒ™ã‚¯ãƒˆãƒ«ä½¿ç”¨ï¼‰
- ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†ææ©Ÿèƒ½

---

## 10. æ‰¿èª

æœ¬ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸ã®å†…å®¹ã«ã¤ã„ã¦ç¢ºèªã—ã€æ‰¿èªã—ã¾ã™ã€‚

- è¨­è¨ˆè€…: Claude (AI Assistant)
- ãƒ¬ãƒ“ãƒ¥ãƒ¼è€…: Dr. Ninomiya
- æ‰¿èªæ—¥: ___________
