## ページ 1

セキュリティの基本
はじめに
前章までの学習内容
この章では、「セキュリティ」というテーマが皆さんのWebアプリケーション開発において、いか
に重要な「基礎工事」であるかを確認していきます。また、専門家アシスタントであるAI（Claude
Code）に対し、私たちが持つプロンプトスキルをどのように応用していくか、その心構えについ
ても共有しますね。
この章の目標
いよいよ、セキュリティ編の第一歩を踏み出します。この章を読み終える頃には、あなたは以下の
ことができるようになっているはずです。
Webアプリケーションに潜む「リスク」とは何か、具体的なイメージを持って説明できるよ
うになる
「通信を盗まれる」とはどういうことか、そしてそれがどのような事態を引き起こすのかを理
解する
皆さんが選択したNext.jsとSupabaseという技術が、基本的なセキュリティ対策をいかに担
ってくれるかを知り、安心感を得る
「セキュリティ」と聞くと、少し堅苦しく、難しく感じるかもしれません。ご安心ください。ここ
では、一つ一つ身近な例に置き換えながら、その本質をじっくりと見ていきましょう。
Webアプリケーションに潜む「リスク」とは？
Webアプリケーションは、素敵なお店のようなものです。この例えを、もう少し深掘りしてみまし
ょう。
皆さんのWebアプリケーションには、ユーザーが安心して利用するために預けてくれる、たくさん
の「貴重品」が存在します。
個人情報: 氏名、メールアドレス、住所、電話番号など
認証情報: ログインIDと、何よりも重要なパスワード
決済情報: もしECサイトなら、クレジットカード情報


## ページ 2

ユーザー生成コンテンツ: ユーザーが時間をかけて書き込んだ日記、投稿、写真など、その
人にとってかけがえのないデータ
これらの「貴重品」が、悪意のある第三者によって「盗まれる」「壊される」「勝手に使われる」と
いった危険に晒されている状態。それが、Webアプリケーションにおける「リスク」です。
お店の運営者が、お客様の安全や預かった品物に対して責任を負うように、Webアプリケーション
の運営者である私たちもまた、ユーザーから預かったこれらの「貴重品」に対して、責任を負わな
ければなりません。セキュリティ対策とは、その責任を果たすための、具体的で誠実な行動なので
す。
特に注意すべき、基本的な2つのリスク
では、具体的に「盗まれる」とは、どのような手口で行われるのでしょうか。ここでは、数あるリ
スクの中でも、最も基本的で理解しやすい二つのシナリオを見ていきましょう。
リスク1：通信の盗聴（手紙の盗み見）
ユーザーがあなたのWebアプリケーションを使うとき、ユーザーのパソコンやスマートフォンと、
アプリケーションが動いているサーバーとの間で、絶えず情報のやり取り（通信）が発生していま
す。
この情報のやり取りを、「手紙の郵送」に例えてみましょう。
もし、この手紙が「はがき」で送られていたらどうでしょうか。郵便配達の途中、誰でもその内容
を盗み見ることができてしまいますよね。これが、暗号化されていない通信の状態です。
ユーザーがログイン画面でIDとパスワードを入力した瞬間、その情報が「はがき」に乗ってサーバ
ーまで送られていたら…途中で待ち伏せしていた悪意のある人に、いとも簡単にIDとパスワードを
盗み見られてしまいます。
HTTPSとは？
「Hypertext Transfer Protocol Secure」の略です。これは、通信内容を暗号化するための仕組
みで、先ほどの例えで言うと、「はがきを、特殊な鍵でしか開けられない頑丈な金庫に入れてから
郵送する」ようなものです。たとえ途中で金庫ごと盗まれても、正しい鍵を持っていなければ、中
の手紙（情報）を読むことはできません。ウェブサイトのアドレスが「http:// 」ではなく
「https:// 」で始まっているのは、この安全な通信が行われている証です。
なぜ重要なのか？
ユーザーが入力するパスワード、個人情報、クレジットカード番号など、あらゆる機密情報を「盗


## ページ 3

み見」から守るために、現在のWebアプリケーションにとってHTTPSは必須の技術です。これが
なければ、ユーザーは安心してサービスを利用できません。
Next.js/Supabaseでの対応
幸いなことに、Vercelのような現代的なホスティングサービスにNext.jsアプリケーションをデプ
ロイ（公開）すると、通常は簡単な設定、あるいは自動でHTTPSが有効になります。また、
Supabaseとの通信も標準で暗号化されています。つまり、皆さんは技術スタックを選んだ時点
で、この「通信の盗聴」に対する基本的な対策の第一歩を踏み出しているのです。
リスク2：なりすまし（他人のフリ）
さて、もし「通信の盗聴」によって、ユーザーのIDとパスワードが盗まれてしまったら、次は何が
起こるでしょうか。
悪意のある人は、その盗んだIDとパスワードを使って、正規のユーザーになりすましてサービスに
ログインしようとします。これは「他人の家の合鍵を不正に入手して、家の中に侵入する」のと同
じ行為です。
一度「なりすまし」を許してしまうと、被害は深刻です。
登録されている個人情報を全て閲覧される
そのユーザーのアカウントで、勝手に投稿やメッセージ送信が行われる
登録されているメールアドレスやパスワードを変更され、アカウントを乗っ取られる
もし、多くのユーザーが複数のサービスで同じパスワードを使い回していた場合、被害はあなたの
サービスだけに留まらず、他のサービスにまで連鎖的に拡大してしまう可能性すらあります。
もし、情報漏洩が起こってしまったら？
万が一、これらのリスクが現実のものとなり、ユーザーの情報が外部に漏洩してしまった場合、そ
の影響は計り知れません。
ユーザーへの影響
プライバシーが侵害されるだけでなく、実質的な金銭的被害に繋がることもあります。他のサービ
スのアカウントまで危険に晒され、精神的にも大きな苦痛を与えることになります。
サービス運営者（あなた）への影響
何よりもまず、ユーザーからの信頼を一瞬で失います。サービスの評判は地に落ち、ユーザー離れ
は避けられないでしょう。場合によっては、ユーザーに対する損害賠償責任が発生したり、事業の
継続自体が困難になったりすることもあります。
少し厳しい話に聞こえたかもしれません。しかし、これは脅しではなく、私たちがサービスを運営
する上で、常に意識しておくべき現実です。だからこそ、これから学ぶ一つ一つのセキュリティ対


## ページ 4

策が、非常に大きな意味を持ってくるのです。
Next.jsとSupabaseという、頼れる選択
ここまでリスクの話を続けると、「Webアプリを公開するのは、なんて怖いんだ…」と不安に感じ
てしまうかもしれません。ですが、過度に心配する必要はありません。
なぜなら、皆さんがNext.jsやSupabaseといった現代的な技術を選んで開発を進めていること自体
が、最初の、そして最も重要なセキュリティ対策の一つになっているからです。
先ほど触れたように、
HTTPSによる通信の暗号化は、Vercelなどのプラットフォームを使えば、ほぼ標準機能とし
て提供されます
Supabaseは、それ自体が安全な認証機能（ユーザー登録やログイン）を提供しており、パス
ワードを安全に保管する仕組みも内部に備えています
古い技術を使ってゼロから車を組み立てるのではなく、最新の安全基準を満たしたエンジンやシャ
シー（車台）を使って車を作るようなものです。基本的な安全性は、初めから高いレベルで確保さ
れているのです。
良い道具、良い技術基盤を選ぶこと。皆さんは、無意識のうちに、すでにそれを実践できていま
す。自信を持って、次のステップに進みましょう。
まとめ
お疲れ様でした。この章では、セキュリティの重要性について、その輪郭を掴むことができたかと
思います。
Webアプリのリスクとは、ユーザーから預かった「貴重品（情報）」が盗まれたり、壊されたりす
る危険性のことでした。
具体的な脅威として、「通信の盗聴（手紙の盗み見）」と、それによって引き起こされる「なりすま
し（他人のフリ）」という二つのシナリオを見ました。
情報漏洩は、ユーザーと運営者の両方に、計り知れない損害を与える可能性があることを理解しま
した。
そして、Next.jsとSupabaseという現代的な技術スタックが、これらの基本的な脅威に対する防護
策を標準で備えてくれている、心強い味方であることも確認しました。
基本的な通信の安全性は確保されていることが分かりました。しかし、ここで新たな疑問が生まれ
ます。 「個別のデータへのアクセス管理はどうすればいいのだろう？」 「例えば、Aさんのデータ
はAさんにしか見せないようにする、といった細かい設定は？」


## ページ 5

まさしく、それが次のテーマです。次では、その問いに対する強力な答えとなる、Supabaseの素
晴らしい機能「行レベルセキュリティ(RLS)」について学びます。
Supabase RLS入門：RLSで実現するセ
キュアなデータベース
はじめに：Webアプリの「当たり前のプライバシ
ー」とその裏側
あなたが普段、SNSやネットショッピングのサイトを使う時のことを、少し思い出してみてくださ
い。
設定画面を開けば、もちろん自分のメールアドレスやプロフィールが表示されます。でも、他人の
メールアドレスが見えてしまうことはありません。
注文履歴のページを開けば、自分が過去に買った商品の一覧が出てきます。でも、隣の家の人が何
を買ったかを知ることはできません。
SNSで下書き保存した投稿は、後から自分だけが見つけて編集できます。友達がその下書きを勝手
に読んでしまうことはありません。
これらはすべて、私たちにとって「当たり前」のことですよね。 では、視点を変えて、あなたが今
まさに作っているWebアプリケーションの「開発者」の立場になった時、この「当たり前」は、
どうやって実現すればいいのでしょうか？
実は、何もしなければ、データベースに保存された情報は、権限を持つ人なら誰でも見ることがで
きてしまう、非常に危険な状態にあります。つまり、この「当たり前」のプライバシーは、開発者
が意図して、そして正しくセキュリティを組み込まなければ、決して実現できないのです。
章の目標
この章では、その「当たり前」を実現するための、最も強力で確実な仕組みの一つである、
Supabaseの「行レベルセキュリティ（Row-Level Security、以下RLS）」について学びます。
RLSとは、データベース自身が「このデータ（行）は、この人にしか見せてはいけません」「この
操作は、この本人にしか許可しません」という厳格なルールを守るようになる、いわばデータベー
スに内蔵された門番のような機能です。


## ページ 6

ご安心ください。SQLやデータベースの詳しい知識がなくても理解できるよう、一つずつ丁寧に解
説していきます。
この章を読み終える頃には、あなたはこのRLSの仕組みを理解し、SQLというシンプルな命令を使
って、ご自身のアプリケーションに「当たり前」のプライバシーとセキュリティを実装できるよう
になっています。
それでは、ユーザーが安心して使える、信頼性の高いアプリケーションを構築するための、重要な
一歩を踏み出しましょう。
なぜRLSが必要なのか？
「はじめに」の振り返り
前のパートでは、「自分に関係のない情報は見えない」というWebアプリケーションの「当たり前」
のプライバシーが、開発者の意図的なセキュリティ設計によって実現されていること、そしてその
中核をなすのがSupabaseのRLSであることを学びました。
では、なぜNext.jsのプログラムの中で「ログインしているユーザーのデータだけを取得する」とい
った制御を行うだけではダメなのでしょうか？ この章では、その根本的な理由を解き明かし、RLS
がなぜ「不可欠」なのかを深く理解していきます。
Next.jsに設定するSupabaseのキーたち：その
役割と使い分け
SupabaseのプロジェクトをNext.jsと連携させる際、.env.localのようなファイルに、いくつかの
URLやキーを設定します。これらは似たような文字列に見えるかもしれませんが、実はそれぞれ全
く異なる、重要な役割を持っています。これらの違いを正確に理解することが、セキュリティを考
える上でのすべての土台となります。
NEXT_PUBLIC_SUPABASE_URL
これはシンプルに、あなたのSupabaseプロジェクトの「住所」です。Next.jsアプリケーション
が、インターネット上のどこにあるデータベースと通信すればよいのかを示すための情報です。
NEXT_PUBLIC_SUPABASE_ANON_KEY


## ページ 7

これが、今回最も重要なキーです。まず、名前の先頭に NEXT_PUBLIC_ と付いていることに注目
してください。これはNext.jsのルールで、「このキーは、最終的にブラウザ（クライアント）に渡
され、誰でも見ることができる公開情報になりますよ」ということを示しています。
anon とは "anonymous"（匿名の）の略で、このキーはあなたのアプリケーションを訪れたすべ
てのユーザー（ログインしていない匿名のユーザーも含む）が、Supabaseと通信するために共通
で使う「通行証」のようなものです。
他の重要な値と同様、Supabaseのプロジェクトの設定画面から取得することが可能です。
SUPABASE_SERVICE_ROLE_KEY
一方、こちらのキーには NEXT_PUBLIC_ が付いていません。これは、絶対にブラウザ側に漏ら
してはならない、サーバーサイド専用の「秘密の鍵」であることを意味します。
これはデータベースのすべてのルール（RLSさえも）を無視して、あらゆる操作ができてしまう
「管理者用のマスターキー」です。そのため、Next.jsのAPI Routesやサーバーコンポーネントと
いった、ユーザーからは直接見えないサーバー側の処理でのみ、細心の注意を払って使用します。
anon keyが必要になるタイミング
ここであなたは疑問に思うかもしれません。
「以前アプリを作った時、anon keyは設定しませんでした。このキーはいつ必要になるのです
か？」
素晴らしい質問です。結論から言うと、「ブラウザ（クライアント）から直接Supabaseと少しで
も通信するなら、anon keyは必須です」となります。
もう少し詳しく見ていきましょう。
anon key は、ブラウザで動くJavaScriptがSupabaseと会話するための唯一の窓口です。
ログイン機能がないアプリの場合: 例えば、「誰でも見れるブログ記事の一覧」や「公開された商品
リスト」をデータベースから取得して、画面に表示する機能を考えてみましょう。この「データベ
ースからデータを取得する」という処理をブラウザ側で行う場合、その通信の際には必ず anon
key が必要になります。このキーを使って、「匿名の一般客ですが、公開されている情報を見せてく
ださい」とリクエストを送るわけです。
ログイン機能があるアプリの場合: ログイン機能があるアプリでも、話は同じです。
ログイン前: ユーザーは「匿名の一般客」です。この状態で公開記事などを読む際には、anon key
を使って通信します。
ログイン成功後: ユーザーがIDとパスワードで認証に成功すると、Supabaseは内部的に「この通
信は、正真正銘の〇〇さんからのものです」という特別な証（JWTという電子証明書）を発行しま


## ページ 8

す。その後も、通信の窓口として使われるのは同じ anon key ですが、リクエストにこの「特別な
証」が自動的に添付されるようになります。
つまり、anon key は、認証前と認証後の両方で使われ続ける、クライアントサイド通信の土台な
のです。
もしあなたが「anon key を設定しなかった」のにアプリが動いているとすれば、それはおそら
く、Next.jsのサーバーサイドの機能（API RoutesやgetStaticProps/getServerSidePropsな
ど）を使って、サーバー側だけでSupabaseとの通信を完結させているからでしょう。その場合
は、クライアントにキーを公開する必要がないため、anon key は不要です。今後、必要になるか
もしれないとだけ覚えておきましょう。
ユーザーの操作に応じてデータを表示するなど、少しでもブラウザ側からの操作でSupabaseと通
信する機能を実装するならば、anon key は必須の環境変数となります。
anon keyを使ったリクエストは「自己申告」
さて、anon key が「誰でも使える公開された通行証」である、ということは何を意味するのでし
ょうか。
それは、この anon key を使ったリクエストは、根本的に「自己申告」に過ぎない、ということ
です。
悪意のあるユーザーがブラウザの機能を使えば、あなたのアプリケーションの anon key は簡単に
見つかります。これは、防ぐことができません。
そして、そのキーを使えば、あなたの作ったNext.jsのプログラムを一切経由せずに、Supabaseの
APIを直接実行することが技術的に可能です。
つまり、攻撃者は、あなたの用意したプログラムを無視して、次のような偽のリクエストを直接デ
ータベースに送ることができるのです。
「anon key（共通の通行証）を持っています。ところで、ユーザーIDが "xyz-789"（他人のID）
の人の個人情報をください。」
もし、データベース側に何の防御策もなければ、このリクエストは正当なものとして扱われ、他人
の個人情報が簡単に盗み出されてしまうでしょう。
データベース自身が「門番」になる必要性


## ページ 9

「でも、Next.jsのコードで、ログイン中のユーザーIDと一致するデータしか取得しないように書
いておけばいいのでは？」と思うかもしれません。 確かに、それは善良なユーザーを正しい画面へ
案内するための、必要な実装です。
しかし、その制御はあくまでアプリケーションの「表玄関」での話です。APIを直接叩くという
「裏口」からの不正なアクセスを防ぐことはできません。
そこで、RLSの出番です。 RLSとは、リクエストを受け取ったデータベース自身が、厳格な「門
番」として機能する仕組みです。
RLSが有効になっているデータベースは、リクエストを受け取ると、次のように考えます。
「ふむ、anon key（通行証）は持っているな。建物に入ることは許可しよう。」
「次に、あなたは誰だ？（ログイン済みなら、Supabase Authが保証する本人情報を確認する）」
「なるほど、ユーザーID "abc-123" の本人だな。」
「では、あなたがアクセスしようとしているこのデータは、本当に "abc-123" さん自身のもの
か？（私（データベース）が持っているルール（ポリシー）と照合しよう）」
「ルールに合致している。よろしい、このデータへのアクセスを許可する。」
このように、クライアントからの「自己申告」を鵜呑みにせず、データベースが持つ絶対的なルー
ルに基づいてアクセスを許可・拒否する。これこそが、RLSが実現するセキュリティの本質です。
Next.jsのプログラムがいかに巧妙に作られていても、最後の砦であるデータベース自身が堅牢でな
ければ、真の安全性は確保できません。だからこそ、私たちはRLSを学ぶ必要があるのです。
この章のまとめ
Next.jsで使う anon key は公開情報であり、ブラウザからSupabaseと通信する際の「共通の通
行証」である。
ブラウザ側でデータをやり取りする機能があるなら、ログイン機能の有無に関わらず anon key は
必須。
anon key を使ったリクエストは「自己申告」であり、悪意のあるユーザーはAPIを直接操作して
他人になりすますことが可能である。
そのため、クライアント側のプログラムだけでなく、データベース自身が「門番」として機能する
RLSが不可欠である。
RLSの必要性はご理解いただけたかと思います。 次の章では、その「門番」が従うルールブックで
ある「ポリシー」を、SQLを使ってどのように記述していくのか、その基本を学んでいきましょ
う。


## ページ 10

RLSの仕組みとSQLの基本ルール
前章の振り返り
前の章では、Supabaseのダッシュボードから取得できるanon keyという値が「誰でも使える共通
の通行証」であり、それを使ったリクエストは「自己申告」に過ぎないため、プログラムの制御だ
けではセキュリティとして不十分であることを学びました。そして、その根本的な解決策が、デー
タベース自身が「門番」として機能するRLSである、という結論に至りました。
この章では、その「門番」がどのようなルールに基づいて動いているのか、そして私たちがそのル
ールをSQLという言語を使ってどのように定義していくのか、その仕組みと基本を解き明かしてい
きます。
RLSの基本原則：「原則として、すべてを疑う」
RLSを理解する上で、最も重要なたった一つの原則があります。それは、「デフォルトで、すべて
のアクセスを全面禁止する」という考え方です。
Supabaseのテーブルに対して、あなたがRLSを有効にするスイッチをONにした瞬間、そのテーブ
ルは外部からのあらゆるアクセスを完全にブロックする、鉄壁の要塞と化します。たとえ正しい
anon key を使ってリクエストを送っても、データベースは「アクセス権がありません」と冷たく
返すだけです。
これは「ブラックリスト方式」（問題があるものだけを禁止する）の逆で、「ホワイトリスト方式」
と呼ばれます。つまり、「このアクセスは安全です」と私たちが明示的に許可したルール（ポリシ
ー）に合致するリクエストだけを、例外的に通すのです。
この「原則として、すべてを疑う」という姿勢こそが、RLSが非常に安全である理由の根幹をなし
ています。
アクセスルールを定義するSQL：CREATE POLIC
Y


## ページ 11

では、その「許可リスト」は、どのように作成すればよいのでしょうか。 ここで、データベースと
対話するための言語、SQLが登場します。RLSのルール（ポリシー）は、CREATE POLICY という
SQL文を使って定義します。
基本的な構文は、以下のようになります。
1
2
CREATE POLICY "ポリシーに付ける分かりやすい名前"
ON public."テーブル名" -- この後に、具体的なルールを記述していく
CREATE POLICY "ポリシー名" : これから新しいポリシーを作りますよ、という宣言です。ポリシ
ーには、後から見て「ああ、これは投稿を本人だけが編集できるようにするルールだな」と分かる
ような、具体的な名前を付けます。
ON public."テーブル名" : このポリシーが、どのテーブルに対するルールなのかを指定します。例
えば posts テーブルや profiles テーブルがここに入ります。
2-3. ルールの適用範囲：「どのテーブル」に「何
の操作」を許可するか
ポリシーは、テーブルの特定の操作（コマンド）に対して設定します。Webアプリケーションで使
われる主な操作は、以下の4つです。
SELECT : データを閲覧する
INSERT : 新しいデータを作成する
UPDATE : 既存のデータを更新する
DELETE : データを削除する
CREATE POLICY 文では、FOR というキーワードを使って、このポリシーがどの操作に対するも
のなのかを明示します。
1
2
3
4
5
6
-- SELECT（閲覧）操作に対するポリシーの場合 FOR SELECT
-- INSERT（作成）操作に対するポリシーの場合 FOR INSERT
-- すべての操作（SELECT, INSERT, UPDATE, DELETE）に
共通のポリシーを適用したい場合 FOR ALL
これにより、「このテーブルのデータの閲覧は許可するが、新しいデータの作成は許可しない」と
いった、操作ごとの細かい制御が可能になります。


## ページ 12

解説：Supabaseが保証する「本人の証明書」au
th.uid()
さて、ここでRLSの心臓部とも言える、非常に重要な仕組みを紹介します。それが auth.uid() で
す。 これは、データベースのルールの中で使える、「今まさに操作している、ログイン中の本人」
を指し示す、特別なキーワードだと考えてください。
なぜ auth.uid() は信頼できるのか？
ユーザーがメールアドレスとパスワードでログインに成功すると、その認証を行うのはSupabase
自身（Supabase Auth）です。ログインに成功した証として、Supabaseはユーザー一人ひとりに
対して、「世界で絶対に他人と被ることがない、その人専用の特別なID」(UUIDと言います)を発
行し、管理しています。
そして、あなたがSQLでポリシー（ルール）を書く際に、その文の中に auth.uid() というキーワ
ードを記述すると、面白いことが起こります。
データベースは、そのリクエストを受け取った瞬間に、auth.uid() と書かれた部分を、UUID に内
部で自動的に置き換えてからルールを解釈してくれるのです。
1
2
3
4
5
-- 例えば、SQL文に user_id = auth.uid() と書いたとすると…
-- データベースが内部で解釈する時には、
-- user_id = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'  ←こんな感じの、
本物のIDに置き換わっている！
これは、前章で問題にした、クライアントからの「自己申告」のIDとは全く次元の違う話です。
auth.uid() は、データベースがサーバー側でログイン情報を元に保証してくれる、偽造不可能で
100%信頼できる「本人の証明書」なのです。
この auth.uid() という強力な武器を手に入れたことで、「操作しようとしているデータは本当にこ
の本人のものか？」というアクセス制御の最も重要な条件を、安全に記述することができるように
なります。
条件を記述する USING と WITH CHECK


## ページ 13

最後に、ポリシーの具体的な条件を記述する方法を見ていきましょう。ここには USING と WITH
CHECK という、二つのキーワードが登場します。
USING句：どの行へのアクセスを許可するかの「フィルタ
ー」
USING 句は、主に閲覧（SELECT）や、更新・削除（UPDATE/DELETE）の対象となる行を絞
り込むための条件を定義します。SQLの WHERE 句に非常に似ており、「この条件に合致する行だ
けが、操作の対象として見えますよ/扱えますよ」というフィルターの役割を果たします。
1
2
3
4
5
6
-- SELECT操作で、is_publishedという列にtrueと保存されている投稿だけを
許可するポリシー
CREATE POLICY "公開投稿は誰でも閲覧可能"
ON public.posts
FOR SELECT
USING ( is_published = true );
この例では、is_published カラム（列）の値が true である行だけが、SELECT の対象となりま
す。下書き状態の記事は弾く、といった条件の実現に使えます。
WITH CHECK句：書き込みを許可するかの「チェックリ
スト」
WITH CHECK 句は、主に作成（INSERT）や更新（UPDATE）の際に、書き込もうとしているデ
ータがルールに合っているかを検証するための条件を定義します。「この条件を満たさないデータは
データベースへの書き込みを許可しません」という、データの整合性を守るチェックリストの役割
です。
1
2
3
4
 -- INSERT操作で、自分のID（auth.uid()）を持つ投稿だけを許可するポリシー
CREATE POLICY "投稿は本人のみ作成可能" ON public.posts
 FOR INSERT
 WITH CHECK ( user_id = auth.uid() );
この例では、新しく INSERT しようとしているデータの user_id カラムの値がログイン中の本人
のID (auth.uid()) と一致しなければ書き込みを拒否します。
USINGとWITH CHECKの使い分け
SELECT (閲覧): どの行が見える？ → USING を使う。
DELETE (削除): どの行を消せる？ → USING を使う。


## ページ 14

INSERT (作成): どんなデータを書き込める？ → WITH CHECK を使う。
UPDATE (更新): どの行を更新できて、どんな内容にできる？ → USING (対象行の選択) と WITH
CHECK (更新後の内容のチェック) の両方を使うことが多い。
この章のまとめ
RLSの基本原則は「デフォルトで全面禁止」のホワイトリスト方式である。
ルールは CREATE POLICY というSQL文でテーブルと操作（SELECTなど）ごとに定義すること
ができる。
auth.uid() は、Supabaseが保証する信頼できる「本人の証明書」であり、ポリシーの要とな
る。
USING は閲覧などの際のフィルター条件、WITH CHECK は書き込みの際のチェック条件を定義
する。
これらの基本的な構成要素を理解すれば、もうRLSポリシーを読み書きする準備は万端です。 次の
章からは、いよいよこれらの知識を組み合わせて、SNSアプリやECサイトといった具体的なアプリ
ケーションの「当たり前」の機能を、SQLでどのように実現していくのかを見ていきましょう。
【ユースケース別①】SNSアプリで学ぶR
LSポリシーの実践
前章の振り返り
前の章では、RLSの基本的な仕組みと、ポリシーを定義するためのSQLのルールを学びました。
「デフォルトで全面禁止」という原則から始まり、CREATE POLICY、FOR、USING、WITH
CHECK、そして信頼できる本人確認のための auth.uid() といった、RLSを構成する重要な要素を
一つずつ見てきました。
この章からは、いよいよ実践です。これらの知識を組み合わせて、私たちが普段使っているような
SNSアプリケーションの「当たり前」の機能が、RLSポリシーによってどのように実現されている
のかを、具体的なユースケースに沿って見ていきましょう。
導入：SNSアプリのデータベースを想定する


## ページ 15

これから、シンプルなSNSアプリを例に考えていきます。このアプリのデータベースには、主に2つ
のテーブルが存在するとします。
posts テーブル：ユーザーの投稿を保存するテーブル
id: 投稿一つ一つを識別するためのID
content: 投稿の本文
user_id: この投稿を書いたユーザーのID (auth.uid() と対応)
is_published: trueなら公開、falseなら下書き状態を示す
profiles テーブル：ユーザーのプロフィール情報を保存する
テーブル
id: ユーザー一人ひとりを識別するためのID (auth.uid() と対応)
username: ユーザー名
email: メールアドレス
最も重要な最初のステップ：これからポリシーを設定していく上で、大前提となる作業があります。そ
れは、これらのテーブルに対してRLSを有効化することです。これを忘れると、どんなにポリシーを作成
しても意味がありません。
1
2
3
4
5
-- postsテーブルでRLSを有効にする 
alter table public.posts enable row level security;
-- profilesテーブルでRLSを有効にする 
alter table public.profiles enable row level security;
このSQLを実行した瞬間から、これらのテーブルは鉄壁の要塞となり、私たちがこれから作成する
「許可証（ポリシー）」がなければ、誰もアクセスできなくなります。
機能要件：投稿の作成 (INSERT)
実現したい「当たり前」: 「ログインしているユーザーは、新しい投稿を作成できる」
これは、新しいデータを作成する操作なので、INSERT に対するポリシーが必要です。そして、
「どんなデータなら書き込みを許可するか」というチェックが必要なので、WITH CHECK 句を使
います。
チェックすべき条件はシンプルです。「これから投稿されるデータの user_id が、今ログインして
いる本人のID (auth.uid()) と一致していること」。 これにより、悪意のあるユーザーが、他人に


## ページ 16

なりすまして投稿することをデータベースレベルで完全に防ぎます。
1
2
3
4
5
6
7
CREATE POLICY "新しい投稿は本人のみ作成可能"
-- どのテーブルに対するルールか
ON public.posts
-- どの操作に対するルールか
FOR INSERT
-- どんなデータを許可するかのチェック条件
WITH CHECK ( user_id = auth.uid() );
機能要件：投稿の編集・削除 (UPDATE/DELETE)
実現したい「当たり前」: 「ユーザーは、自分自身が過去に投稿した内容だけを編集・削除できる」
これは、既存のデータを更新 (UPDATE) または削除 (DELETE) する操作です。 これらの操作で
は、「そもそも、どの行を操作対象として見せるか」というフィルターが重要になるため、USING
句を使います。
フィルターの条件は、「操作したい行の user_id が、今ログインしている本人のID (auth.uid())
と一致していること」です。この条件に合致しない行は、そのユーザーにとっては最初から「存在
しない」のと同じになり、編集や削除の対象にすらなりません。
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
-- UPDATE（更新）に対するポリシー
CREATE POLICY "投稿は本人のみ更新可能"
ON public.posts
FOR UPDATE
-- どの行を操作対象とするかのフィルター条件
USING ( user_id = auth.uid() );
-- DELETE（削除）に対するポリシー
CREATE POLICY "投稿は本人のみ削除可能"
ON public.posts
FOR DELETE
-- どの行を操作対象とするかのフィルター条件
USING ( user_id = auth.uid() );
機能要件：タイムラインの表示 (SELECT)
実現したい「当たり前」: 「公開設定の投稿は誰でも見れるが、下書き投稿は本人しか見れない」


## ページ 17

これは、データを閲覧する操作なので、SELECT に対するポリシーが必要です。そして、どの行が
見えるかのフィルターなので、USING 句を使います。
ここでの条件は、少しだけ複雑になります。以下のどちらかの条件を満たせば、閲覧を許可したい
ですよね。
その投稿が公開されている (is_published が true)
その投稿が、自分自身のものである (user_id が auth.uid() と一致する)
このような「A または B」という条件は、SQLの OR を使って表現します。
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
CREATE POLICY "公開投稿は誰でも、自分の投稿は全て閲覧可能"
ON public.posts
FOR SELECT
USING (
  -- 条件1：公開されているか
  is_published = true
  -- または
  OR
  -- 条件2：自分自身の投稿であるか
  user_id = auth.uid()
);
このポリシーにより、ログインしていない匿名のユーザーは条件1の公開投稿しか見ることができま
せん。一方、ログインしているユーザーは、すべての公開投稿に加えて、自分だけの下書き投稿
（条件2）も見ることができるようになります。
3-4. 機能要件：ユーザー設定ページの保護 (SEL
ECT/UPDATE)
実現したい「当たり前」: 「ユーザーは、自分自身のユーザー設定ページの情報のみを閲覧・更新
できる」
今度は profiles テーブルが舞台です。自分のプロフィールは自分だけが見れて、自分だけが編集で
きる。これもプライバシー保護の基本です。 この要件を実現するには、閲覧 (SELECT) と更新
(UPDATE) の両方に、ほぼ同じ条件のポリシーを設定します。
 1
 2
 3
 4
-- SELECT（閲覧）に対するポリシー
CREATE POLICY "自身のプロフィールのみ閲覧可能"
ON public.profiles
FOR SELECT


## ページ 18

 5
 6
 7
 8
 9
10
11
12
13
-- どの行を閲覧対象とするかのフィルター条件
USING ( id = auth.uid() );
-- UPDATE（更新）に対するポリシー
CREATE POLICY "自身のプロフィールのみ更新可能"
ON public.profiles
FOR UPDATE
-- どの行を更新対象とするかのフィルター条件
USING ( id = auth.uid() );
これらのポリシーでは、profiles テーブルの id（ユーザーを識別するID）が、ログイン中の本人の
ID (auth.uid()) と完全に一致する行だけを、閲覧・更新の対象として許可しています。 これによ
り、他人には自分のプロフィール情報が一切見えず、もちろん編集されることもない、という「当
たり前」がデータベースレベルで保証されます。
この章のまとめ
SNSアプリの様々な「当たり前」の機能が、RLSポリシーによって実現されていることを見た。
INSERT (作成) では WITH CHECK を使い、書き込むデータが正しいかを検証した。
UPDATE (更新) / DELETE (削除) では USING を使い、操作対象のデータを本人自身のものに限
定した。
SELECT (閲覧) では USING と OR を組み合わせ、公開情報と個人情報を両立させる方法を学ん
だ。
ここまでで、RLSの基本的な使い方と、具体的な実装イメージがかなり掴めてきたのではないでし
ょうか。 次の章では、もう一つの身近な例として、決済機能を持つECサイトを舞台に、RLSがど
のようにユーザーの購買情報を守っているのかを見ていきましょう。
【ユースケース別②】ECサイトで学ぶRL
Sポリシーの実践
前章の振り返り
前の章では、SNSアプリを例にして、投稿の作成・編集・閲覧や、プロフィールの保護といった、
具体的な機能要件をRLSポリシーで実現する方法を学びました。「本人にしか操作させない」とい
うセキュリティの基本を、auth.uid() を使ってSQLで記述する感覚が掴めてきたかと思います。


## ページ 19

この章では、舞台をECサイト（ネットショップ）に移してみましょう。 ECサイトでは、商品情
報、ショッピングカート、そして何よりも大切な注文履歴といった、より機密性の高いデータを扱
います。このような場面でも、RLSが同じ原則に基づいて、いかにユーザーの情報を守ってくれる
のかを、具体的なユースケースと共に見ていきましょう。
導入：ECサイトのデータベースを想定する
これから解説するECサイトには、以下の3つの主要なテーブルが存在するとします。
products テーブル：販売している商品情報を保存するテー
ブル
id: 商品ID
name: 商品名
price: 価格
cart_items テーブル：各ユーザーのショッピングカートの
中身を保存するテーブル
id: カート内アイテムのID
product_id: どの商品のIDか
quantity: 数量
user_id: 誰のカートのアイテムか (auth.uid() と対応)
orders テーブル：ユーザーの注文履歴を保存するテーブル
id: 注文ID
total_price: 合計金額
user_id: 誰の注文か (auth.uid() と対応)
SNSアプリの時と同様に、これらのテーブルには、あらかじめRLSが有効化されているものとして
話を進めます。
機能要件：商品情報の閲覧 (SELECT)
実現したい「当たり前」: 「全ての商品は、ログイン状態に関わらず誰でも閲覧できる」
ECサイトの商品カタログは、お店のショーウィンドウのようなものです。ログインしていない人も
含め、誰もが自由に見ることができなければなりません。


## ページ 20

これは「公開情報」なので、閲覧（SELECT）操作に対して、すべての行へのアクセスを許可する
ポリシーが必要です。 このような「常に許可」という条件は、USING句に true を指定することで
表現できます。これは、「このポリシーの条件は、どんな行に対しても常に真（true）です」とい
う意味になり、結果として全行の閲覧が許可されます。
1
2
CREATE POLICY "商品は誰でも閲覧可能" ON public.products FOR 
SELECT USING( true );
機能要件：ショッピングカートの制御 (全操作)
実現したい「当たり前」: 「ユーザーは、自分自身のカートの中身だけを閲覧・追加・変更・削除
できる」
ショッピングカートは、極めてプライベートな空間です。あなたがカートに入れた商品を、他の人
が見たり、勝手に追加したり削除したりできては絶対にいけません。
つまり、cart_items テーブルに対するすべての操作（閲覧、作成、更新、削除）は、厳格に本人
に限定する必要があります。 このような場合、FOR ALL を使って、4つの操作に共通のポリシー
を一度に設定すると効率的です。
条件は、閲覧・更新・削除の対象を絞る USING と、作成・更新時のデータをチェックする WITH
CHECK の両方で、「cart_itemsテーブルの user_id が、本人のID (auth.uid()) と一致すること」
とします。
1
2
3
4
CREATE POLICY "カートは本人のみ操作可能" ON public.cart_items -- SELECT, 
  INSERT, UPDATE, DELETE の全てに適用 FOR ALL -- 閲覧・更新・削除の対象を
  本人に限定 USING ( user_id = auth.uid() ) -- 作成・更新時に、必ず本人のIDが
  設定されるよう強制 WITH CHECK ( user_id = auth.uid() ); 
この一つのポリシーで、カートの中身が他人に見られることも、他人のカートを操作してしまうこ
とも、完全に防ぐことができます。
機能要件：注文履歴の保護 (SELECT/INSERT)
実現したい「当たり前」: 「ユーザーは、自分自身の注文履歴だけを閲覧でき、また自分自身の注
文としてのみ新しい履歴を作成できる」
注文履歴は、ユーザーの購買活動そのものであり、個人情報の中でも特に機密性が高いデータで
す。この保護は、ECサイトの信頼性の根幹をなします。


## ページ 21

ここでの要件は、SNSアプリの投稿機能と非常によく似ています。
閲覧 (SELECT): 自分の注文履歴だけが見えるようにする。
作成 (INSERT): 新しい注文履歴は、必ず自分のものとして作成されるようにする。
（通常、一度確定した注文履歴をユーザー自身が更新・削除することは稀なので、ここでは
UPDATE と DELETE のポリシーは考えないことにします。）
もう、あなたならどのようなポリシーを書けばよいか、想像がつきますね。
1
2
3
4
5
6
7
-- SELECT（閲覧）に対するポリシー CREATE POLICY "
  自身の注文履歴のみ閲覧可能" ON public.orders FOR SELECT -- どの行を閲覧対象と
  するかのフィルター条件 USING ( user_id = auth.uid() );
-- INSERT（作成）に対するポリシー CREATE POLICY "
  自身の注文としてのみ作成可能" ON public.orders FOR INSERT -- どんなデータを
許可するかのチェック条件 WITH CHECK ( user_id = auth.uid() );
まさに、SNSアプリのプロフィール保護や投稿作成で学んだパターンが、そのまま応用できるので
す。 RLSの強力な点は、このようにアプリケーションの種類が変わっても、「誰のデータか」を識
別するカラム（user_idなど）さえあれば、同じ原則で一貫したセキュリティを適用できることに
あります。
この章のまとめ
ECサイトという、より機密性の高いデータを扱うアプリケーションでも、RLSの基本的な原則は全
く同じであることを確認した。
USING (true) を使えば、商品カタログのような「公開情報」を誰にでも安全に表示できることを
学んだ。
ショッピングカートや注文履歴といった極めてプライベートな情報は、user_id = auth.uid() とい
う条件を徹底することで、確実に本人だけに限定できることを見た。
SNSアプリで学んだポリシーの記述パターンが、ECサイトでもそのまま応用できることを通じて、
RLSの汎用性の高さを理解した。
SNSアプリ、ECサイトと、2つの具体的なユースケースを見てきました。これで、あなたのアプリ
ケーションに「当たり前」のプライバシーを実装するための、SQLの武器はほぼ手に入れたと言っ
て良いでしょう。 次の最終章では、このRLSという強力な仕組みを前提とすると、私たちの開発ス
タイル全体がどのように変わっていくのか、そのメリットと今後の指針について考えていきます。


## ページ 22

RLSを前提とした開発へ
前章の振り返り
前の2つの章では、SNSアプリとECサイトという具体的なユースケースを通じて、様々な機能要件
をRLSポリシーで実現する方法を学びました。user_id = auth.uid() というシンプルな条件式が、
いかに強力にユーザーのプライバシーを守ってくれるか、ご理解いただけたかと思います。
この最終章では、視点をデータベースからNext.jsのコードに戻します。 RLSという強力な門番を
データベースに配置したことで、私たちの普段のコーディングはどのように変わるのでしょうか？
そして、開発全体に対する考え方は、どう進化するべきなのでしょうか？
セキュリティをデータベースに集約するメリット
RLSを導入する最大のメリットの一つは、アクセス制御に関する複雑なロジックを、アプリケーシ
ョンのコードから分離できることです。
もしRLSがなければ、私たちはNext.jsのコードの至る所で、アクセス制御のチェック処理を書く
必要があり、コードは複雑になり、見通しが悪くなります。そして、たった一箇所のチェック漏れ
が、致命的なセキュリティホールに繋がる危険性が常に付きまといます。
しかし、RLSを正しく設定すれば、この状況は一変します。 データベース自身が門番として振る舞
ってくれるので、Next.jsのコードは、「誰のデータか」を過度に意識する必要がなくなり、非常に
シンプルで読みやすい状態に保たれるのです。（その具体的な仕組みについては、後述のコラムで詳
しく解説します。）
AIアシスタントと共にRLSポリシーを作成する
「RLSが重要なのは分かったけど、いざ自分でSQLを書くのは難しそう…」と感じたかもしれませ
ん。その通り、RLSのポリシーはSQLという専門的な言語で記述する必要があり、正確に書くには
知識が求められます。


## ページ 23

しかし、心配は無用です。私たちには、この分野の専門家であるAIアシスタントがいます。私たち
がやるべきことは、SQLを一行ずつ書くことではなく、「私たちのアプリが、どのようなルールで
動いてほしいのか」という要件を、日本語で正確に伝えることです。
ここでは、架空の「ブログアプリ」を例に、AIにRLSポリシーの作成を依頼するプロンプトを考え
てみましょう。
シナリオ：ブログアプリのセキュリティ要件
テーブル構成:
profilesテーブル: ユーザーのプロフィール情報（id, usernameなど）
postsテーブル: ユーザーのブログ投稿（id, title, content, user_id (投稿者のID),
is_published (公開フラグ)など）
実現したいルール:
誰でも公開されている投稿(is_publishedがtrueのもの)は読むことができる。
ユーザーは、自分自身の投稿（下書き含む）をすべて読むことができる。
ユーザーは、自分自身の投稿だけを作成、更新、削除できる。
ユーザーは、自分自身のプロフィール情報だけを更新できる。
（今回はシンプルにするため、プロフィールは誰でも読めることにします）
さあ、この要件をAIアシスタントに伝えてみましょう。
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
Supabaseのデータベースに、行レベルセキュリティ(RLS)ポリシーを設定したいです。
 以下の要件を満たすための、テーブルごとのSQLポリシーを網羅的に生成してください。
◾️前提条件
データベースには profiles テーブルと posts テーブルが存在します。
profiles テーブルにはユーザーIDを示す id カラムが、posts テーブルには投稿者を示す 
user_id カラムと、公開状態を示す is_published カラム（boolean型）があります。
Supabaseの認証機能を利用しており、ログイン中のユーザーIDは auth.uid() で
取得できます。
◾️postsテーブルのRLSポリシー要件 【SELECT (閲覧)】
is_published が true の投稿は、誰でも（ログインしていないユーザーも）
閲覧可能とする。
ログインしているユーザーは、自身の user_id と一致する投稿を、is_published の
状態に関わらず閲覧可能とする。
【INSERT (作成)】


## ページ 24

20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
ログインしているユーザーは、自身の user_id を持つ投稿のみ作成可能とする。
【UPDATE (更新)】
ログインしているユーザーは、自身の user_id と一致する投稿のみ更新可能とする。
【DELETE (削除)】
ログインしているユーザーは、自身の user_id と一致する投稿のみ削除可能とする。
◾️profilesテーブルのRLSポリシー要件 【SELECT (閲覧)】
全てのプロフィール情報は、誰でも閲覧可能とする。
【UPDATE (更新)】
ログインしているユーザーは、自身の id と一致するプロフィールのみ更新可能とする。
良いプロンプトを書くためのポイント
単に「RLSを設定して」とお願いするのではなく、以下のポイントを守ります。
ポイント1：「4つの操作」に分けて指示を出す 「データベースからの取り出し(SELECT)」「データ
ベースへの保存(INSERT)」「データベースの更新(UPDATE)」「データベースからの削除
(DELETE)」という4つの動作に分けて、それぞれルールを考えましょう。
ポイント2：「誰が」を明確にする 「ログインしているユーザー」「ログインしていないユーザー」
というように、誰が操作するのかを主語にして考えると、ルールが明確になります。
ポイント3：細かなケースを言語化する 「投稿一覧」や「投稿詳細ページ」といった画面レベルで
はなく、「公開されている投稿」「本人の下書き投稿」のように、データの状態に基づいた、より細
かなレベルでルールを記述しましょう。
このように、曖昧さを徹底的に排除し、アシスタントが迷うことなく仕事を進められるように「要
件定義」をしてあげることが、AIを使いこなす上での非常に重要なコツなのです。
このプロンプトをClaude CodeのようなAIに渡せば、専門家であるアシスタントは、これらの要
件を正確に満たすSQLのコードを生成してくれるはずです。私たちは、その生成されたコードを
SupabaseのSQL Editorに貼り付けて実行するだけで、鉄壁のアクセス管理を実現できます。


## ページ 25

「セキュリティ・バイ・デザイン」という考え方
AIという強力なパートナーを得た私たちは、開発に対する考え方を少しだけアップデートすること
ができます。それが、「セキュリティ・バイ・デザイン（Security by Design）」という考え方で
す。
これは、「後からセキュリティ対策を追加する」のではなく、「アプリケーションを設計する最初の
段階から、セキュリティを組み込んでおく」というアプローチです。
SupabaseとRLSにおける「セキュリティ・バイ・デザイン」とは、具体的には次のことを意味し
ます。
新しいテーブルを設計する時、常に自問する：「このデータは、誰のものか？」
ユーザーが作成する投稿（posts）テーブルには、必ず user_id カラムを追加する。
ユーザーのプロフィール（profiles）テーブルの主キーは、auth.users テーブルの id を参照する
ように設定する。
ユーザー間の関連データ（例えば「いいね」）を保存するテーブルには、「誰が (user_id)」「何を
(post_id)」いいねしたのかを記録するカラムを必ず設ける。
このように、データと「所有者」を常に関連付けて設計しておくことで、後から user_id =
auth.uid() というシンプルかつ強力なRLSポリシーを、迷うことなく適用できるようになります。
テーブルを作成したら、まず最初にRLSを有効にし、AIアシスタントと共に基本的なポリシーを設
定する。これを、新しいコンポーネントを作るのと同じくらい「当たり前」の開発フローに組み込
むこと。 それが、将来のあなたのアプリケーションを、予期せぬ脆弱性から守るための、最も確実
な一歩となるのです。
おわりに：信頼こそが、アプリケーショ
ンの価値を高める
ここまで学習を進めてこられた皆さん、本当にお疲れ様でした。 この章を通じて、Supabaseの行
レベルセキュリティ(RLS)という、一見すると専門的で難解に見える技術の、その本質と実践方法
を学んできました。


## ページ 26

この章で、私たちが歩んできた道のり
最後に、この章で何を学んできたのかを、改めて振り返ってみましょう。
「当たり前」への問いかけから始まった 私たちの旅は、「なぜ他人の個人情報が見えないのか？」
という、普段使っているアプリケーションの「当たり前」のプライバシーへの素朴な疑問から始ま
りました。
RLSの必要性を理解した そして、Next.jsのプログラム制御だけでは不十分であり、クライアント
から偽装可能な「自己申告」のリクエストからデータを守るためには、データベース自身が厳格な
「門番」として機能する必要があることを学びました。
門番のルールブック（SQL）を読み解いた CREATE POLICY、USING、WITH CHECK といった
SQLの基本ルールと、偽造不可能な「本人の証明書」である auth.uid() の仕組みを理解し、門番
に指示を出すための言葉を手に入れました。
具体的なユースケースで実践した SNSアプリやECサイトといった身近な例を通じて、投稿の制
御、タイムラインの表示、カートや注文履歴の保護といった、様々な「当たり前」の機能を、SQL
ポリシーでどのように実現するのかを具体的に見てきました。
AIと共に開発するスタイルを知った 複雑なSQLポリシーも、AIアシスタントに正確な日本語で要件
を伝えれば、高品質な草案を作成してくれることを知りました。そして、RLSを前提とした「セキ
ュリティ・バイ・デザイン」という考え方が、いかに私たちのアプリケーションを堅牢にし、開発
をシンプルにしてくれるかを確認しました。
RLSがもたらす、本当の価値
この章で学んだRLSは、単なるセキュリティ技術の一つではありません。 それは、あなたのアプリ
ケーションの「信頼」を形作る、最も重要な土台です。
ユーザーは、あなたのサービスが自分の大切な情報を、まるで自分のことのように真剣に守ってく
れると信じるからこそ、安心して個人情報を預け、サービスを使い続けてくれます。RLSを正しく
実装することは、その信頼に対する、開発者としての最も誠実な応え方なのです。
そして、この信頼の土台は、アプリケーションの価値そのものを高めます。 セキュリティという厄
介な問題をデータベース層に集約することで、あなたはアプリケーション本来の機能開発や、より
良いユーザー体験の創造に、安心して集中することができます。


## ページ 27

あなたの、次の一歩へ
この章は、ここで終わりです。しかし、あなたの開発者としての旅は、ここからが新しい始まりで
す。 ぜひ、今日学んだ知識を、あなたのプロジェクトで活かしてみてください。
まず、あなたのSupabaseプロジェクトで、ユーザーデータを扱うすべてのテーブルに対して、RLS
を有効にしてみましょう。
次に、この章で学んだユースケースを参考に、あなたのアプリの機能要件を日本語で書き出してみ
てください。
そして、その要件を元に、AIアシスタントにRLSポリシーの作成を依頼し、生成されたSQLを実行
してみましょう。
完璧なセキュリティに終わりはありません。しかし、基本を徹底すること、そして「原則としてす
べてを疑う」というRLSの思想を常に心に留めておくことが、あなたのアプリケーションと、その
ユーザーを、未来の未知なる脅威から守るための最も確実な道筋となります。
あなたは、Webアプリケーションの「当たり前」の裏側を知り、それを自らの手で構築するための
強力な知識とツールを手に入れました。 自信を持って、ユーザーから信頼される、価値あるアプリ
ケーションの開発を続けていってください。
応援しています。
代表的なサイバー攻撃とその対策
はじめに
前章までの学習内容
前章では、データベースを「巨大なマンション」に例え、そのセキュリティの要である「行レベル
セキュリティ(RLS)」について学びました。RLSという賢い管理人を導入することで、ユーザーは
自分に関係のあるデータ（自分の部屋）にしかアクセスできなくなり、情報が安全に守られること
を理解しましたね。また、その複雑な設定も、AIアシスタントに的確なプロンプトで依頼すれば実
現できることを確認しました。


## ページ 28

この章の目標
データベースという「情報の保管庫」は、かなり頑丈になりました。しかし、悪意のある攻撃者
は、また別の角度から侵入を試みてきます。この章では、Webアプリケーションそのものを標的と
した、代表的な攻撃手口について学んでいきましょう。この章を終える頃には、あなたは以下のこ
とができるようになります。
「クロスサイトスクリプティング(XSS)」や「SQLインジェクション」といった、代表的な攻
撃がどのようなものかを、具体的なイメージで理解できる
なぜそれらの攻撃が危険なのか、その仕組みを説明できるようになる
皆さんが使っているNext.jsという技術が、これらの攻撃に対して、いかに強力な防御策を標
準で備えているかを知り、さらなる安心感を得る
専門的な攻撃名が並びますが、一つずつ、これもまた身近な例えで解説していきます。攻撃者の手
口を知ることは、最高の防御に繋がります。
手口その1：コメント欄に罠を仕掛ける攻撃 (XS
S)
多くのWebアプリケーションには、ユーザーが自由に文章を書き込める場所があります。例えば、
ブログのコメント欄、SNSの投稿フォーム、商品のレビュー欄などです。
この「ユーザーが入力できる」という便利な機能、実は攻撃者にとっては格好の標的になり得ま
す。
ここに、「お店に置かれた、誰でも書き込めるアンケート用紙」を想像してみてください。 ほとん
どのお客様は、真面目に感想や意見を書いてくれます。しかし、ある悪意を持った人物が、ただの
感想文ではなく、「このアンケートを見た人は、全員、自分の財布の中身を差し出す」という特殊
なインクで書かれた命令を書き込んだとしたらどうでしょうか。
もし、店員がその用紙を「お客様の声」として店内に掲示してしまい、それを見た他の人がその命
令に従ってしまったら…大変なことになりますよね。
これと似たようなことが、Webの世界でも起こり得ます。これが「クロスサイトスクリプティング
（Cross-Site Scripting）」、通称XSS と呼ばれる攻撃です。
攻撃者は、コメント欄のような場所に、ただの文章ではなく、ブラウザを操るための悪意のあるプ
ログラム（スクリプト）を書き込みます。そして、何も知らない別のユーザーがそのページを訪れ
ると、そのユーザーのブラウザが、ページに書かれた悪意のあるプログラムを「Webサイトからの
正しい指示」だと勘違いして実行してしまうのです。
結果として、


## ページ 29

偽のログインフォームが表示され、IDとパスワードを盗まれる
ユーザーのブラウザに保存されている情報（クッキー）が盗まれ、アカウントを乗っ取られ
る
といった被害が発生する可能性があります。
XSSとは？
Webアプリケーションの入力フォームなどを通じて、悪意のあるスクリプトをWebページに埋め込
み、それを閲覧した他のユーザーのブラウザ上で実行させる攻撃手法です。
なぜ危険なのか？
ユーザーの個人情報を盗み出したり、セッションを乗っ取ったり（なりすまし）、ウェブサイトを
改ざんしたりと、様々な悪意のある操作を可能にしてしまうため、非常に危険視されています。
Next.jsの対策は？
ご安心ください。Next.js（およびその基盤であるReact）は、このXSS攻撃に対して非常に強力
な防御機構をデフォルトで備えています。Next.jsは、プログラム内で表示されるすべてのデータ
を、原則として「ただの文字列」として扱います。これは「エスケープ処理」と呼ばれるもので、
例えばスクリプトで特別な意味を持つ< や> といった記号を、単なる文字（&lt; や&gt; ）に
自動的に変換してくれるのです。これにより、たとえ攻撃者が悪意のあるスクリプトを書き込んで
も、それはプログラムとして実行されることなく、ただの無害な文字列として画面に表示されるだ
けになります。


## ページ 30

手口その2：データベースへの不正な命令 (SQLイ
ンジェクション)
次に紹介するのは、データベースを直接狙う、非常に強力な攻撃です。
「レストランの注文システム」を例に考えてみましょう。お客様が注文票に「ハンバーグ 1つ」と
書くと、厨房ではそれを見てハンバーグを調理します。
しかし、もしお客様が注文票に「ハンバーグ 1つ。それと、厨房にある食材を全部タダでよこせ」
という、特殊な形式の追記をしたらどうでしょうか。 もし、厨房のシステムがこの追記を「正式な
注文の一部」としてそのまま解釈してしまったら、お店の食材がすべて盗まれてしまいます。
これが「SQLインジェクション」の基本的な考え方です。
Webアプリケーションは、ユーザーがログイン画面で入力したIDやパスワードを元に、「このIDと
パスワードを持つユーザーはいますか？」という問い合わせの命令文（SQL文）を組み立てて、デ
ータベースに送ります。 攻撃者は、この仕組みを悪用します。パスワードの入力欄に、本物のパス
ワードではなく、データベースを不正に操作するためのSQL文の一部を「注入（インジェクショ
ン）」するのです。
もしアプリケーションが、この入力された値を無防備に命令文に連結してしまうと、攻撃者の書い
た不正な命令が、そのままデータベースで実行されてしまいます。結果、パスワードを知らなくて
もログインを突破されたり、データベース内の全ユーザーの情報をごっそり盗み出されたり、最悪
の場合はデータを全て削除されたりする、極めて深刻な被害に繋がります。
SQLインジェクションとは？
Webアプリケーションが想定していないSQL文を意図的に「注入」することにより、データベース
を不正に操作する攻撃手法です。


## ページ 31

なぜ危険なのか？
認証を回避されるだけでなく、データベースに格納されている機密情報（個人情報、カード情報な
ど）の漏洩、データの改ざん、削除など、データベースに対するあらゆる不正操作が可能になるた
め、最も警戒すべき攻撃の一つとされています。
Supabase/Next.jsの対策は？
こちらも、ご安心ください。Supabaseが提供するクライアントライブラリ
（@supabase/supabase-js ）のような、現代的なデータベース操作ツールは、このSQLインジェ
クションを防ぐための仕組みを標準で採用しています。これは「プリペアドステートメント（また
はパラメータ化クエリ）」と呼ばれるものです。先ほどの注文票の例えで言うと、「お客様が書いた
ものは、どんな内容であれ、必ず『注文品名』としてだけ扱いなさい」というルールを厨房で徹底
するようなものです。ユーザーからの入力値を、命令文（SQL）の一部としてではなく、常に単な
る「データ（値）」として区別して扱うため、たとえ入力値にSQLのような文字列が含まれていて
も、それが命令として実行されることはありません。
その他の代表的な攻撃
世の中には、他にも様々な攻撃手法が存在します。ここでは、あと二つだけ、名前と考え方を知っ
ておきましょう。
CSRF (クロスサイトリクエストフォージェリ)
これは、「常連客を装って、偽の注文書を届けさせる」ような攻撃です。ユーザーがあなたのサー
ビスにログインしている状態で、悪意のある別のサイトを訪れると、そのサイトが、ユーザーの意
図とは無関係に、あなたのサービスに対して「商品を勝手に購入する」「退会する」といったリク
エストを強制的に送信する手口です。


## ページ 32

セッションハイジャック
これは、「お店の常連カードを盗んで、その人になりすます」ような攻撃です。何らかの方法で、
ユーザーがログイン状態を維持するために使っている情報（セッションID）を盗み出し、そのユー
ザーになりすましてサービスを不正利用する手口です。
これらの攻撃に対しても、Next.jsのようなフレームワークは、対策を講じるための仕組み（例え
ば、CookieのSameSite属性など）を備えています。フレームワークの標準的な作法に沿って開発
を進めること自体が、自然と防御に繋がることが多いのです。


## ページ 33

AIアシスタントによるセキュリティ総点検
ここまで読んで、「色々な攻撃があるんだな…」と少し不安になったかもしれません。Next.jsや
Supabaseが優秀だとは言っても、「自分のアプリは本当に大丈夫だろうか？」と心配になるのは当
然です。
そんな時こそ、AIアシスタントの出番です。私たちのアプリケーションの概要を伝え、専門家の視
点から潜在的なリスクがないか、チェックしてもらいましょう。
Claude Codeへのプロンプト例
 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
Next.jsとSupabaseで構築しているWebアプリケーションのセキュリティについて、
アドバイスをください。
アプリケーションの概要
（ここに、あなたのアプリがどんなアプリなのかを簡潔に記述してください。
例：ユーザーが日記を投稿・閲覧できるブログサービスです）
（ここに、主要な機能を箇条書きで記述してください。
例：ユーザー登録・ログイン機能、投稿の作成・編集・削除機能、公開投稿の
一覧表示機能など）
質問
このアプリケーションの構成において、クロスサイトスクリプティング(XSS)、
SQLインジェクション、CSRFといった代表的な脆弱性に対して、Next.jsとSupabaseの
標準機能でどのように対策されていますか？
上記以外に、このアプリケーションの特性を考慮した上で、特に注意すべきセキュリティ上
の点があれば指摘してください。
今後、機能を追加していく上で、セキュリティを保つために常に心がけるべきことが
あれば教えてください。
このプロンプトでは、AIに現状の防御策を確認させると同時に、私たちのアプリに特化した、より
踏み込んだアドバイスを求めています。AIからの返答を読むことで、理解が深まるだけでなく、新
たな気づきも得られるはずです。
まとめ


## ページ 34

この章では、アプリケーションを狙う具体的な攻撃手法について学びました。
XSS（クロスサイトスクリプティング）は、コメント欄などに悪意のあるプログラムを仕掛
け、他のユーザーに実行させる攻撃でしたね
SQLインジェクションは、入力フォームに不正な命令を注入し、データベースを直接攻撃す
る危険な手口でした
そして、これらよく知られた攻撃に対して、Next.jsとSupabaseは、標準で強力な防御機構
（エスケープ処理やプリペアドステートメント）を備えていることを確認し、安心材料を得る
ことができました
最後に、AIアシスタントにアプリケーション全体のセキュリティチェックを依頼するため
の、具体的なプロンプトも手に入れました
これで、技術的な側面からのセキュリティ対策に関する基礎知識は、かなり充実してきました。通
信経路を守り、データベースを守り、そしてアプリケーション自体への攻撃手法も学びました。
しかし、完璧なサービスを作るには、もう一つ、非常に重要な要素が残っています。それが「法
律」や「利用規約」といった、社会的なルールとの向き合い方です。次の章では、舞台をがらりと
変え、この「法律編」へと進んでいきます。あなたのサービスが、技術的に安全なだけでなく、社
会的に信頼される存在になるための、最後のピースを埋めにいきましょう！

